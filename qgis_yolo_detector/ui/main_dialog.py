"""
Interface principale du plugin YOLO Interactive Object Detector

Cette interface contient :
- Onglet 1: Gestion des Classes d'Objets
- Onglet 2: Annotation Interactive
- Onglet 3: Entra√Ænement de Mod√®les
- Onglet 4: D√©tection et Application

Workflow utilisateur :
1. Cr√©er des classes d'objets (ex: "Poteaux √©lectriques")
2. Annoter des exemples sur le canvas QGIS
3. Entra√Æner automatiquement un mod√®le YOLO
4. Appliquer le mod√®le sur de vastes zones
"""

import os
from pathlib import Path
from datetime import datetime

from qgis.PyQt.QtCore import Qt, QTimer, pyqtSignal
from qgis.PyQt.QtGui import QIcon, QPixmap, QFont
from qgis.PyQt.QtWidgets import (
    QDialog, QDockWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QTabWidget, QWidget, QLabel, QPushButton, QLineEdit,
    QComboBox, QListWidget, QListWidgetItem, QTextEdit,
    QGroupBox, QFrame, QProgressBar, QCheckBox,
    QFormLayout, QSpinBox, QDoubleSpinBox, QSlider,
    QSplitter, QTreeWidget, QTreeWidgetItem,
    QMessageBox, QFileDialog
)

from qgis.gui import QgisInterface
from qgis.core import QgsProject

# Import de l'outil d'annotation
try:
    from .annotation_tool import InteractiveAnnotationTool
    ANNOTATION_TOOL_AVAILABLE = True
except ImportError:
    ANNOTATION_TOOL_AVAILABLE = False

# Import du gestionnaire de d√©pendances
try:
    from ..utils.dependency_installer import check_dependencies_silent, show_dependency_manager
    DEPENDENCY_MANAGER_AVAILABLE = True
except ImportError:
    DEPENDENCY_MANAGER_AVAILABLE = False

# DatasetManager int√©gr√© dans l'onglet Classes au lieu d'un onglet s√©par√©


class YOLOMainDialog(QDockWidget):
    """Interface principale du plugin YOLO Interactive Object Detector"""
    
    # Signaux
    class_created = pyqtSignal(str)  # Nouvelle classe cr√©√©e
    annotation_requested = pyqtSignal(str)  # Annotation demand√©e pour une classe
    training_requested = pyqtSignal(str)  # Entra√Ænement demand√©
    detection_requested = pyqtSignal(str, dict)  # D√©tection demand√©e
    
    def __init__(self, iface: QgisInterface, parent=None):
        """
        Initialise l'interface principale
        
        Args:
            iface: Interface QGIS
            parent: Widget parent
        """
        super().__init__("üéØ YOLO Interactive Object Detector", parent)
        self.iface = iface
        
        # Configuration du dock widget
        self.setObjectName("YOLOMainDock")
        self.setFeatures(
            QDockWidget.DockWidgetMovable | 
            QDockWidget.DockWidgetFloatable |
            QDockWidget.DockWidgetClosable
        )
        
        # Taille par d√©faut
        self.setMinimumWidth(400)
        self.resize(800, 600)
        
        # Donn√©es
        self.object_classes = {}  # Dict des classes d'objets
        self.current_class = None  # Classe active
        
        # √âtat de l'entra√Ænement
        self.training_in_progress = False
        self.current_dataset_info = None
        # SUPPRIM√â: self.trained_models et self.class_models ‚Üí maintenant en DB
        
        # Outil d'annotation
        self.annotation_tool = None
        if ANNOTATION_TOOL_AVAILABLE:
            self.annotation_tool = InteractiveAnnotationTool(self.iface.mapCanvas())
            # NOUVEAU: R√©f√©rence bidirectionnelle pour Smart Mode
            self.annotation_tool.set_main_dialog(self)
        
        # Gestionnaire d'annotations (AVANT le chargement des donn√©es)
        self.annotation_manager = None
        try:
            from ..core.annotation_manager import get_annotation_manager
            self.annotation_manager = get_annotation_manager()
            print("‚úÖ AnnotationManager initialis√©")
        except ImportError:
            print("‚ö†Ô∏è AnnotationManager non disponible")
        
        # Chargement depuis la base au d√©marrage (APR√àS l'init de annotation_manager)
        self._load_persistent_data()
        
        # V√©rification non-bloquante des d√©pendances (en arri√®re-plan)
        self.dependencies_ok = False
        if DEPENDENCY_MANAGER_AVAILABLE:
            try:
                all_available, missing = check_dependencies_silent()
                if all_available:
                    self.dependencies_ok = True
                    print("‚úÖ Toutes les d√©pendances sont disponibles")
                else:
                    print(f"‚ÑπÔ∏è D√©pendances manquantes (mode annotation disponible): {', '.join(missing)}")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur v√©rification des d√©pendances: {e}")
        
        # Moteur YOLO (initialisation avec gestion d'erreur d√©taill√©e)
        self.yolo_engine = None
        try:
            from ..core.yolo_engine import YOLOEngine
            self.yolo_engine = YOLOEngine()
            print("‚úÖ YOLOEngine initialis√© avec succ√®s")
        except ImportError as e:
            print(f"‚ùå YOLOEngine non disponible - D√©pendances manquantes: {e}")
            print("üí° Installez: pip install ultralytics torch opencv-python")
        except Exception as e:
            print(f"‚ùå Erreur critique initialisation YOLOEngine : {e}")
            import traceback
            traceback.print_exc()
        
        # G√©n√©rateur de datasets YOLO
        self.dataset_generator = None
        try:
            from ..core.yolo_dataset_generator import YOLODatasetGenerator
            self.dataset_generator = YOLODatasetGenerator(self.annotation_manager)
            print("‚úÖ YOLODatasetGenerator (complet) initialis√©")
        except Exception as e:
            print(f"‚ö†Ô∏è YOLODatasetGenerator complet non disponible : {e}")
            # Fallback vers g√©n√©rateur simplifi√©
            try:
                from ..core.simple_dataset_generator import SimpleYOLODatasetGenerator
                self.dataset_generator = SimpleYOLODatasetGenerator(self.annotation_manager)
                print("‚úÖ SimpleYOLODatasetGenerator (fallback) initialis√©")
            except Exception as e2:
                print(f"‚ùå Aucun g√©n√©rateur disponible : {e2}")
        
        # NOUVEAU: Smart Annotation Engine (lazy loading)
        self.smart_engine = None
        self.smart_mode_enabled = False
        
        # Interface
        self.setup_ui()
        
        # Connexions
        self.setup_connections()
        
        # Initialisation - chargement des classes existantes et mise √† jour interface
        print("üîÑ Initialisation de l'interface - chargement des classes existantes...")
        self.load_existing_classes()
        self.update_interface_state()
        
        # Mise √† jour imm√©diate de l'affichage apr√®s initialisation compl√®te
        from qgis.PyQt.QtCore import QTimer
        QTimer.singleShot(100, self.refresh_interface_display)
        print("‚úÖ Initialisation de l'interface termin√©e")
    
    def load_existing_classes(self):
        """Charge les classes existantes depuis l'AnnotationManager"""
        if not self.annotation_manager:
            print("‚ö†Ô∏è AnnotationManager non disponible pour le chargement des classes")
            return
        
        try:
            existing_classes = self.annotation_manager.get_all_classes()
            print(f"üìã Chargement de {len(existing_classes)} classes existantes depuis la base")
            
            classes_loaded = 0
            for class_name in existing_classes:
                if class_name not in self.object_classes:
                    # R√©cup√©rer les statistiques r√©elles de la classe
                    try:
                        stats = self.annotation_manager.get_class_statistics(class_name)
                        class_data = {
                            'name': class_name,
                            'description': f"Classe existante: {class_name}",
                            'examples': [],  # Sera mis √† jour par les statistiques
                            'model_path': None,
                            'created_at': datetime.now(),
                            'color': '#FF0000',
                            'stats': stats  # Ajouter les statistiques
                        }
                        self.object_classes[class_name] = class_data
                        classes_loaded += 1
                        print(f"‚úÖ Classe '{class_name}' charg√©e ({stats.example_count} exemples)")
                    except Exception as e:
                        print(f"‚ö†Ô∏è Erreur chargement statistiques pour '{class_name}': {e}")
                        # Charger quand m√™me la classe avec des donn√©es minimales
                        class_data = {
                            'name': class_name,
                            'description': f"Classe existante: {class_name}",
                            'examples': [],
                            'model_path': None,
                            'created_at': datetime.now(),
                            'color': '#FF0000'
                        }
                        self.object_classes[class_name] = class_data
                        classes_loaded += 1
                        print(f"‚úÖ Classe '{class_name}' charg√©e (statistiques non disponibles)")
            
            print(f"üìä Total: {classes_loaded} classes charg√©es dans l'interface")
            
            # CORRECTION CRITIQUE: Mise √† jour imm√©diate de l'interface apr√®s chargement
            self.update_classes_tree_with_real_stats()
            self.update_class_combos()
            print("üîÑ Interface mise √† jour avec les classes charg√©es")
                    
        except Exception as e:
            print(f"‚ùå Erreur chargement classes existantes: {e}")
            import traceback
            traceback.print_exc()
        
    def setup_ui(self):
        """Construit l'interface utilisateur"""
        
        # Widget central pour le dock widget
        central_widget = QWidget()
        self.setWidget(central_widget)
        
        # Layout principal sur le widget central
        layout = QVBoxLayout(central_widget)
        layout.setSpacing(10)
        
        # En-t√™te avec titre et informations
        header_frame = self.create_header()
        layout.addWidget(header_frame)
        
        # Widget √† onglets principal
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabPosition(QTabWidget.North)
        
        # Onglet 1: Gestion des Classes (AM√âLIOR√âE)
        self.classes_tab = self.create_classes_tab()
        self.tab_widget.addTab(self.classes_tab, "üìÅ Classes d'Objets")
        
        # Onglet 2: Annotation Interactive
        self.annotation_tab = self.create_annotation_tab()
        self.tab_widget.addTab(self.annotation_tab, "üéØ Annotation")
        
        # Onglet 3: Entra√Ænement
        self.training_tab = self.create_training_tab()
        self.tab_widget.addTab(self.training_tab, "üß† Entra√Ænement")
        
        # Onglet 4: D√©tection
        self.detection_tab = self.create_detection_tab()
        self.tab_widget.addTab(self.detection_tab, "üîç D√©tection")
        
        layout.addWidget(self.tab_widget)
        
        # Barre de statut
        status_frame = self.create_status_bar()
        layout.addWidget(status_frame)
        
        # Boutons de contr√¥le
        controls_frame = self.create_controls()
        layout.addWidget(controls_frame)
        
    def create_header(self):
        """Cr√©e l'en-t√™te de l'interface"""
        frame = QFrame()
        frame.setFrameStyle(QFrame.StyledPanel)
        frame.setStyleSheet("""
            QFrame {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #4a90e2, stop:1 #50c8a3);
                border-radius: 8px;
                color: white;
            }
        """)
        
        layout = QHBoxLayout(frame)
        
        # Titre principal
        title_label = QLabel("üéØ YOLO Interactive Object Detector")
        title_font = QFont()
        title_font.setPointSize(16)
        title_font.setBold(True)
        title_label.setFont(title_font)
        title_label.setStyleSheet("color: white;")
        layout.addWidget(title_label)
        
        layout.addStretch()
        
        # Informations de version
        version_label = QLabel("v1.0.0 - D√©veloppement")
        version_label.setStyleSheet("color: rgba(255,255,255,0.8); font-size: 10px;")
        layout.addWidget(version_label)
        
        return frame
    
    def create_classes_tab(self):
        """Cr√©e l'onglet de gestion des classes d'objets"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # Section cr√©ation de classe
        create_group = QGroupBox("‚ûï Cr√©er une Nouvelle Classe")
        create_layout = QFormLayout(create_group)
        
        self.class_name_input = QLineEdit()
        self.class_name_input.setPlaceholderText("Ex: Poteaux √©lectriques")
        create_layout.addRow("Nom de la classe:", self.class_name_input)
        
        self.class_description_input = QTextEdit()
        self.class_description_input.setPlaceholderText(
            "Description d√©taill√©e pour am√©liorer la d√©tection:\n"
            "Ex: 'Structures verticales en b√©ton ou m√©tal,\n"
            "     rectangulaires, hauteur 3-8m, supportant des lignes √©lectriques'"
        )
        self.class_description_input.setMaximumHeight(80)
        create_layout.addRow("Description s√©mantique:", self.class_description_input)
        
        self.create_class_btn = QPushButton("üéØ Cr√©er Classe")
        self.create_class_btn.setMinimumHeight(35)
        self.create_class_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        create_layout.addRow(self.create_class_btn)
        
        layout.addWidget(create_group)
        
        # Section liste des classes
        list_group = QGroupBox("üìã Classes Existantes")
        list_layout = QVBoxLayout(list_group)
        
        self.classes_tree = QTreeWidget()
        self.classes_tree.setHeaderLabels(["Classe", "Exemples", "Statut", "Actions"])
        self.classes_tree.setRootIsDecorated(False)
        self.classes_tree.setAlternatingRowColors(True)
        list_layout.addWidget(self.classes_tree)
        
        layout.addWidget(list_group)
        
        # Boutons d'action
        actions_frame = QFrame()
        actions_layout = QHBoxLayout(actions_frame)
        
        self.view_detail_btn = QPushButton("üìä Vue D√©taill√©e")
        self.edit_class_btn = QPushButton("‚úèÔ∏è Modifier")
        self.duplicate_class_btn = QPushButton("üìã Dupliquer")
        self.delete_class_btn = QPushButton("üóëÔ∏è Supprimer")
        self.export_class_btn = QPushButton("üì§ Exporter")
        
        actions_layout.addWidget(self.view_detail_btn)
        actions_layout.addWidget(self.edit_class_btn)
        actions_layout.addWidget(self.duplicate_class_btn)
        actions_layout.addWidget(self.delete_class_btn)
        actions_layout.addStretch()
        actions_layout.addWidget(self.export_class_btn)
        
        # Connecter le bouton vue d√©taill√©e
        self.view_detail_btn.clicked.connect(self.show_class_detail)
        
        layout.addWidget(actions_frame)
        
        return widget
    
    def create_annotation_tab(self):
        """Cr√©e l'onglet d'annotation interactive"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # S√©lection de classe active
        class_group = QGroupBox("üéØ Classe Active")
        class_layout = QFormLayout(class_group)
        
        self.active_class_combo = QComboBox()
        self.active_class_combo.addItem("--- Aucune classe s√©lectionn√©e ---")
        # CORRECTION: Connexion du signal de changement de s√©lection
        self.active_class_combo.currentTextChanged.connect(self.on_active_class_changed)
        class_layout.addRow("Classe √† annoter:", self.active_class_combo)
        
        layout.addWidget(class_group)
        
        # Outils d'annotation
        tools_group = QGroupBox("üõ†Ô∏è Outils d'Annotation")
        tools_layout = QGridLayout(tools_group)
        
        # Mode d'annotation g√©om√©trique
        tools_layout.addWidget(QLabel("Forme:"), 0, 0)
        
        self.bbox_mode_btn = QPushButton("üî≤ Rectangle")
        self.bbox_mode_btn.setCheckable(True)
        self.bbox_mode_btn.setChecked(True)
        tools_layout.addWidget(self.bbox_mode_btn, 0, 1)
        
        self.polygon_mode_btn = QPushButton("üìê Polygone")
        self.polygon_mode_btn.setCheckable(True)
        tools_layout.addWidget(self.polygon_mode_btn, 0, 2)
        
        # NOUVEAU: Mode d'assistance IA
        tools_layout.addWidget(QLabel("Intelligence:"), 1, 0)
        
        self.manual_mode_btn = QPushButton("‚úã Manuel")
        self.manual_mode_btn.setCheckable(True)
        self.manual_mode_btn.setChecked(True)
        self.manual_mode_btn.setToolTip("Annotation manuelle classique")
        tools_layout.addWidget(self.manual_mode_btn, 1, 1)
        
        self.smart_mode_btn = QPushButton("ü§ñ Smart Assistant")
        self.smart_mode_btn.setCheckable(True)
        self.smart_mode_btn.setToolTip("IA assist√©e : YOLO + SAM pour pr√©cision optimale")
        self.smart_mode_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:checked {
                background-color: #2E7D32;
                box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            }
            QPushButton:hover {
                background-color: #66BB6A;
            }
        """)
        tools_layout.addWidget(self.smart_mode_btn, 1, 2)
        
        # Contr√¥les principaux
        self.start_annotation_btn = QPushButton("üéØ Commencer l'Annotation")
        self.start_annotation_btn.setMinimumHeight(40)
        self.start_annotation_btn.setCheckable(True)
        self.start_annotation_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:checked {
                background-color: #FF5722;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
        """)
        tools_layout.addWidget(self.start_annotation_btn, 2, 0, 1, 2)
        
        # NOUVEAU: Bouton d√©tection automatique Smart Mode
        self.auto_detect_btn = QPushButton("ü§ñ D√©tection Auto")
        self.auto_detect_btn.setMinimumHeight(40)
        self.auto_detect_btn.setToolTip("Smart Mode : YOLO d√©tecte automatiquement les objets dans la zone visible")
        self.auto_detect_btn.setStyleSheet("""
            QPushButton {
                background-color: #9C27B0;
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 11px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #BA68C8;
            }
            QPushButton:disabled {
                background-color: #E0E0E0;
                color: #9E9E9E;
            }
        """)
        self.auto_detect_btn.setEnabled(False)  # Activ√© uniquement en Smart Mode
        tools_layout.addWidget(self.auto_detect_btn, 2, 2)
        
        layout.addWidget(tools_group)
        
        # NOUVEAU: Panneau configuration Smart Mode (masqu√© par d√©faut)
        self.smart_config_group = QGroupBox("ü§ñ Configuration Smart Assistant")
        self.smart_config_group.setVisible(False)  # Masqu√© par d√©faut
        smart_config_layout = QFormLayout(self.smart_config_group)
        
        # Seuil de confiance YOLO
        self.yolo_confidence_slider = QSlider(Qt.Horizontal)
        self.yolo_confidence_slider.setMinimum(10)
        self.yolo_confidence_slider.setMaximum(50)
        self.yolo_confidence_slider.setValue(20)  # 20% par d√©faut
        self.yolo_confidence_slider.setToolTip("Seuil de confiance pour la d√©tection YOLO pr√©alable")
        
        self.yolo_confidence_label = QLabel("20%")
        yolo_conf_layout = QHBoxLayout()
        yolo_conf_layout.addWidget(self.yolo_confidence_slider)
        yolo_conf_layout.addWidget(self.yolo_confidence_label)
        smart_config_layout.addRow("Confiance YOLO:", yolo_conf_layout)
        
        # Options SAM
        self.enable_sam_checkbox = QCheckBox("Activer raffinement SAM")
        self.enable_sam_checkbox.setChecked(True)
        self.enable_sam_checkbox.setToolTip("Utilise SAM pour optimiser la pr√©cision des contours")
        smart_config_layout.addRow("", self.enable_sam_checkbox)
        
        # NOUVEAU: Option contours pr√©cis
        self.precise_contours_checkbox = QCheckBox("üî∫ G√©n√©rer contours pr√©cis (polygones)")
        self.precise_contours_checkbox.setChecked(True)
        self.precise_contours_checkbox.setToolTip("Extrait les contours polygonaux pr√©cis depuis les masques SAM pour l'entra√Ænement")
        smart_config_layout.addRow("", self.precise_contours_checkbox)
        
        # Validation automatique
        self.auto_validation_checkbox = QCheckBox("Validation automatique (confiance > 80%)")
        self.auto_validation_checkbox.setChecked(True)
        self.auto_validation_checkbox.setToolTip("Accepte automatiquement les d√©tections tr√®s confiantes")
        smart_config_layout.addRow("", self.auto_validation_checkbox)
        
        # Mode debug
        self.debug_mode_checkbox = QCheckBox("Mode debug (logs d√©taill√©s)")
        self.debug_mode_checkbox.setChecked(False)
        self.debug_mode_checkbox.setToolTip("Affiche des informations d√©taill√©es sur le processus IA")
        smart_config_layout.addRow("", self.debug_mode_checkbox)
        
        # Statut Smart Engine
        self.smart_status_label = QLabel("‚è≥ Smart Engine non initialis√©")
        self.smart_status_label.setStyleSheet("color: #FF9800; font-style: italic; font-size: 10px;")
        smart_config_layout.addRow("Statut:", self.smart_status_label)
        
        layout.addWidget(self.smart_config_group)
        
        # Progression et exemples
        progress_group = QGroupBox("üìä Progression")
        progress_layout = QVBoxLayout(progress_group)
        
        # Barre de progression
        self.annotation_progress = QProgressBar()
        self.annotation_progress.setMinimum(0)
        self.annotation_progress.setMaximum(20)  # 20 exemples recommand√©s
        self.annotation_progress.setValue(0)
        self.annotation_progress.setFormat("Exemples: %v / %m (Minimum: 10)")
        progress_layout.addWidget(self.annotation_progress)
        
        # Liste des exemples
        self.examples_list = QListWidget()
        self.examples_list.setMaximumHeight(120)
        progress_layout.addWidget(self.examples_list)
        
        # Statistiques
        self.stats_label = QLabel("üìà Aucun exemple collect√©")
        self.stats_label.setStyleSheet("color: #666; font-style: italic;")
        progress_layout.addWidget(self.stats_label)
        
        layout.addWidget(progress_group)
        
        return widget
        
    def create_training_tab(self):
        """Cr√©e l'onglet d'entra√Ænement de mod√®les"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # S√©lection du mod√®le √† entra√Æner
        model_group = QGroupBox("üß† Configuration d'Entra√Ænement")
        model_layout = QFormLayout(model_group)
        
        self.training_class_combo = QComboBox()
        model_layout.addRow("Classe √† entra√Æner:", self.training_class_combo)
        
        self.base_model_combo = QComboBox()
        self.base_model_combo.addItems([
            "yolo11n.pt (Ultra-rapide, 5MB - Recommand√© pour tests)",
            "yolo11s.pt (√âquilibr√©, 19MB - Optimal qualit√©/vitesse)", 
            "yolo11m.pt (Haute pr√©cision, 39MB - Maximum performances)"
        ])
        # S√©lection par d√©faut : mod√®le √©quilibr√©
        self.base_model_combo.setCurrentIndex(1)
        model_layout.addRow("Mod√®le de base:", self.base_model_combo)
        
        layout.addWidget(model_group)
        
        # Param√®tres d'entra√Ænement
        params_group = QGroupBox("‚öôÔ∏è Param√®tres")
        params_layout = QFormLayout(params_group)
        
        self.epochs_spin = QSpinBox()
        self.epochs_spin.setRange(10, 200)
        self.epochs_spin.setValue(50)
        params_layout.addRow("Nombre d'√©poques:", self.epochs_spin)
        
        self.batch_size_spin = QSpinBox()
        self.batch_size_spin.setRange(1, 32)
        self.batch_size_spin.setValue(8)
        params_layout.addRow("Taille de batch:", self.batch_size_spin)
        
        self.learning_rate_spin = QDoubleSpinBox()
        self.learning_rate_spin.setRange(0.0001, 0.1)
        self.learning_rate_spin.setValue(0.001)
        self.learning_rate_spin.setDecimals(4)
        params_layout.addRow("Taux d'apprentissage:", self.learning_rate_spin)
        
        layout.addWidget(params_group)
        
        # Contr√¥les d'entra√Ænement
        training_group = QGroupBox("üöÄ Entra√Ænement")
        training_layout = QVBoxLayout(training_group)
        
        self.train_btn = QPushButton("üöÄ G√©n√©rer Dataset")
        self.train_btn.setMinimumHeight(40)
        self.train_btn.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
            QPushButton:disabled {
                background-color: #ccc;
            }
        """)
        training_layout.addWidget(self.train_btn)
        
        # Barre de progression d'entra√Ænement
        self.training_progress = QProgressBar()
        self.training_progress.setVisible(False)
        training_layout.addWidget(self.training_progress)
        
        # Zone de logs
        self.training_logs = QTextEdit()
        self.training_logs.setMaximumHeight(100)
        self.training_logs.setPlaceholderText("Les logs d'entra√Ænement appara√Ætront ici...")
        training_layout.addWidget(self.training_logs)
        
        layout.addWidget(training_group)
        
        return widget
        
    def create_detection_tab(self):
        """Cr√©e l'onglet de d√©tection et application"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # S√©lection du mod√®le
        model_group = QGroupBox("üîç Configuration de D√©tection")
        model_layout = QFormLayout(model_group)
        
        # NOUVEAUT√â: S√©lection par classe d'objet
        self.detection_class_combo = QComboBox()
        self.detection_class_combo.addItem("--- S√©lectionner une classe ---")
        self.detection_class_combo.currentIndexChanged.connect(self.on_detection_class_index_changed)
        model_layout.addRow("üéØ D√©tecter la classe:", self.detection_class_combo)
        
        # OU s√©lection par mod√®le (mode expert)
        self.detection_model_combo = QComboBox()
        self.detection_model_combo.addItem("--- Aucun mod√®le disponible ---")
        model_layout.addRow("üîß Mod√®le expert:", self.detection_model_combo)
        
        self.confidence_slider = QSlider(Qt.Horizontal)
        self.confidence_slider.setRange(1, 100)
        self.confidence_slider.setValue(10)  # ‚úÖ Valeur par d√©faut plus permissive
        
        self.confidence_label = QLabel("0.10")
        confidence_frame = QFrame()
        confidence_layout = QHBoxLayout(confidence_frame)
        confidence_layout.addWidget(self.confidence_slider)
        confidence_layout.addWidget(self.confidence_label)
        
        model_layout.addRow("Seuil de confiance:", confidence_frame)
        
        layout.addWidget(model_group)
        
        # NOUVEAUT√â: Informations d'√©chelle
        scale_group = QGroupBox("üìê Informations d'√âchelle")
        scale_layout = QFormLayout(scale_group)
        
        self.scale_info_label = QLabel("S√©lectionner une classe pour voir les informations d'√©chelle")
        self.scale_info_label.setWordWrap(True)
        self.scale_info_label.setStyleSheet("""
            QLabel {
                background-color: #f0f8ff;
                border: 1px solid #b0c4de;
                border-radius: 4px;
                padding: 8px;
                color: #333;
            }
        """)
        scale_layout.addRow(self.scale_info_label)
        
        layout.addWidget(scale_group)
        
        # Zone de traitement
        processing_group = QGroupBox("üéØ Zone de Traitement")
        processing_layout = QVBoxLayout(processing_group)
        
        # Options de zone
        zone_frame = QFrame()
        zone_layout = QHBoxLayout(zone_frame)
        
        self.current_view_radio = QCheckBox("Vue actuelle du canvas")
        self.current_view_radio.setChecked(True)
        zone_layout.addWidget(self.current_view_radio)
        
        self.custom_extent_radio = QCheckBox("Emprise personnalis√©e")
        zone_layout.addWidget(self.custom_extent_radio)
        
        self.full_layer_radio = QCheckBox("Couche compl√®te")
        zone_layout.addWidget(self.full_layer_radio)
        
        processing_layout.addWidget(zone_frame)
        
        layout.addWidget(processing_group)
        
        # Bouton de d√©tection
        detect_group = QGroupBox("üöÄ Lancer la D√©tection")
        detect_layout = QVBoxLayout(detect_group)
        
        self.detect_btn = QPushButton("üîç D√©tecter les Objets")
        self.detect_btn.setMinimumHeight(40)
        self.detect_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:disabled {
                background-color: #ccc;
            }
        """)
        detect_layout.addWidget(self.detect_btn)
        
        # Barre de progression de d√©tection
        self.detection_progress = QProgressBar()
        self.detection_progress.setVisible(False)
        detect_layout.addWidget(self.detection_progress)
        
        layout.addWidget(detect_group)
        
        # R√©sultats
        results_group = QGroupBox("üìä R√©sultats")
        results_layout = QVBoxLayout(results_group)
        
        self.results_label = QLabel("Aucune d√©tection effectu√©e")
        self.results_label.setStyleSheet("color: #666; font-style: italic;")
        results_layout.addWidget(self.results_label)
        
        layout.addWidget(results_group)
        
        return widget
    
    def create_status_bar(self):
        """Cr√©e la barre de statut"""
        frame = QFrame()
        frame.setFrameStyle(QFrame.StyledPanel)
        layout = QHBoxLayout(frame)
        
        self.status_label = QLabel("üü¢ Plugin charg√© - Pr√™t √† utiliser")
        layout.addWidget(self.status_label)
        
        layout.addStretch()
        
        # Indicateur GPU/CPU
        self.device_label = QLabel("üíª CPU")
        layout.addWidget(self.device_label)
        
        return frame
    
    def create_controls(self):
        """Cr√©e les boutons de contr√¥le"""
        frame = QFrame()
        layout = QHBoxLayout(frame)
        
        # Bouton aide
        help_btn = QPushButton("‚ùì Aide")
        help_btn.clicked.connect(self.show_help)
        layout.addWidget(help_btn)
        
        # Bouton param√®tres
        settings_btn = QPushButton("‚öôÔ∏è Param√®tres")
        settings_btn.clicked.connect(self.show_settings)
        layout.addWidget(settings_btn)
        
        # Bouton gestionnaire de d√©pendances
        if DEPENDENCY_MANAGER_AVAILABLE:
            deps_btn = QPushButton("üì¶ D√©pendances")
            deps_btn.clicked.connect(self.show_dependency_manager)
            layout.addWidget(deps_btn)
        
        layout.addStretch()
        
        # Bouton fermer
        close_btn = QPushButton("‚úÖ Fermer")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)
        
        return frame
        
    def setup_connections(self):
        """Configure les connexions de signaux"""
        
        # Onglet Classes
        self.create_class_btn.clicked.connect(self.create_new_class)
        self.classes_tree.itemSelectionChanged.connect(self.on_class_selection_changed)
        
        # CORRECTION: Connexions manquantes pour les boutons de gestion des classes
        self.edit_class_btn.clicked.connect(self.edit_selected_class)
        self.duplicate_class_btn.clicked.connect(self.duplicate_selected_class)
        self.delete_class_btn.clicked.connect(self.delete_selected_class)
        self.export_class_btn.clicked.connect(self.export_selected_class)
        
        # Onglet Annotation
        self.start_annotation_btn.toggled.connect(self.toggle_annotation_mode)
        self.bbox_mode_btn.toggled.connect(self.on_annotation_mode_changed)
        self.polygon_mode_btn.toggled.connect(self.on_annotation_mode_changed)
        
        # NOUVEAU: Connexions Smart Mode
        self.manual_mode_btn.toggled.connect(self.on_intelligence_mode_changed)
        self.smart_mode_btn.toggled.connect(self.on_intelligence_mode_changed)
        self.auto_detect_btn.clicked.connect(self.start_smart_auto_detection)
        
        # NOUVEAU: Connexions configuration Smart Mode
        self.yolo_confidence_slider.valueChanged.connect(self.update_yolo_confidence_label)
        self.enable_sam_checkbox.toggled.connect(self.on_smart_config_changed)
        self.precise_contours_checkbox.toggled.connect(self.on_smart_config_changed)
        self.auto_validation_checkbox.toggled.connect(self.on_smart_config_changed)
        self.debug_mode_checkbox.toggled.connect(self.on_smart_config_changed)
        
        # Connexions outil d'annotation
        if self.annotation_tool:
            self.annotation_tool.annotation_created.connect(self.on_annotation_created)
            self.annotation_tool.tool_activated.connect(self.on_annotation_tool_activated)
            self.annotation_tool.tool_deactivated.connect(self.on_annotation_tool_deactivated)
        
        # Connexions gestionnaire d'annotations
        if self.annotation_manager:
            self.annotation_manager.annotation_added.connect(self.on_annotation_added)
            self.annotation_manager.statistics_updated.connect(self.on_statistics_updated)
        
        # Connexions g√©n√©rateur de datasets
        if self.dataset_generator:
            self.dataset_generator.dataset_generation_started.connect(self.on_dataset_generation_started)
            self.dataset_generator.dataset_generation_progress.connect(self.on_dataset_generation_progress)
            self.dataset_generator.dataset_generation_completed.connect(self.on_dataset_generation_completed)
            self.dataset_generator.dataset_generation_error.connect(self.on_dataset_generation_error)
        
        # Onglet Entra√Ænement
        self.train_btn.clicked.connect(self.start_training)
        
        # Onglet D√©tection
        self.detect_btn.clicked.connect(self.start_detection)
        self.confidence_slider.valueChanged.connect(self.update_confidence_label)
        
        # Mises √† jour d'interface
        self.tab_widget.currentChanged.connect(self.on_tab_changed)
        
    def create_new_class(self):
        """Cr√©e une nouvelle classe d'objet"""
        name = self.class_name_input.text().strip()
        description = self.class_description_input.toPlainText().strip()
        
        if not name:
            QMessageBox.warning(self, "Erreur", "Veuillez saisir un nom de classe.")
            return
            
        if name in self.object_classes:
            QMessageBox.warning(self, "Erreur", f"La classe '{name}' existe d√©j√†.")
            return
        
        # Cr√©ation de la classe
        class_data = {
            'name': name,
            'description': description,
            'examples': [],
            'model_path': None,
            'created_at': datetime.now(),
            'color': '#FF0000'  # Rouge par d√©faut
        }
        
        self.object_classes[name] = class_data
        
        # Enregistrement dans la base de donn√©es
        if self.annotation_manager:
            try:
                self.annotation_manager.create_class(name, description, class_data['color'])
                print(f"‚úÖ Classe '{name}' enregistr√©e dans la base de donn√©es")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur enregistrement classe dans la base: {e}")
        
        # Mise √† jour de l'interface
        if self.annotation_manager:
            self.update_classes_tree_with_real_stats()
        else:
            self.update_classes_tree()
        self.update_class_combos()
        
        # S√©lection automatique de la nouvelle classe
        items = self.classes_tree.findItems(name, Qt.MatchExactly, 0)
        if items:
            self.classes_tree.setCurrentItem(items[0])
            self.current_class = name
            
            # Mise √† jour des combos avec la nouvelle s√©lection
            self.active_class_combo.setCurrentText(name)
        
        # Force la mise √† jour de l'√©tat de l'interface
        self.update_interface_state()
        
        # CORRECTION: Ajouter un mod√®le fictif pour test si pas de YOLOEngine
        trained_models = self.annotation_manager.get_trained_models()
        if not self.yolo_engine and not trained_models:
            self._add_test_model(name)
        
        # Nettoyage du formulaire
        self.class_name_input.clear()
        self.class_description_input.setPlainText("")
        
        # Message de succ√®s
        self.status_label.setText(f"‚úÖ Classe '{name}' cr√©√©e avec succ√®s - Pr√™te pour l'annotation")
        
        # √âmet le signal
        self.class_created.emit(name)
    
    def update_classes_tree(self):
        """Met √† jour l'arbre des classes"""
        self.classes_tree.clear()
        
        for name, data in self.object_classes.items():
            item = QTreeWidgetItem([
                name,
                str(len(data['examples'])),
                "üü¢ Pr√™t" if len(data['examples']) >= 10 else "‚ö†Ô∏è Incomplet",
                ""
            ])
            self.classes_tree.addTopLevelItem(item)
    
    def update_class_combos(self):
        """Met √† jour les combos de s√©lection de classe"""
        # Sauvegarde des s√©lections actuelles
        current_active = self.active_class_combo.currentText()
        current_training = self.training_class_combo.currentText()
        
        # Vidage et remplissage
        self.active_class_combo.clear()
        self.training_class_combo.clear()
        
        if not self.object_classes:
            self.active_class_combo.addItem("--- Aucune classe disponible ---")
            self.training_class_combo.addItem("--- Aucune classe disponible ---")
        else:
            self.active_class_combo.addItem("--- S√©lectionner une classe ---")
            self.training_class_combo.addItem("--- S√©lectionner une classe ---")
            
            for name in self.object_classes.keys():
                self.active_class_combo.addItem(name)
                self.training_class_combo.addItem(name)
        
        # Restauration des s√©lections si possibles
        active_index = self.active_class_combo.findText(current_active)
        if active_index >= 0:
            self.active_class_combo.setCurrentIndex(active_index)
        else:
            # CORRECTION: Si pas de s√©lection restaur√©e, prendre la premi√®re classe disponible
            if len(self.object_classes) > 0:
                first_class = list(self.object_classes.keys())[0]
                first_index = self.active_class_combo.findText(first_class)
                if first_index >= 0:
                    # Bloquer les signaux temporairement pour √©viter la double activation
                    self.active_class_combo.blockSignals(True)
                    self.active_class_combo.setCurrentIndex(first_index)
                    self.active_class_combo.blockSignals(False)
                    
                    # D√©finir manuellement la classe active
                    self.current_class = first_class
                    print(f"üéØ Classe active auto-s√©lectionn√©e: {first_class}")
                    
                    # Mise √† jour de l'interface
                    self.update_annotation_progress()
                    self.update_examples_list()
            
        training_index = self.training_class_combo.findText(current_training)
        if training_index >= 0:
            self.training_class_combo.setCurrentIndex(training_index)
    
    def _load_persistent_data(self):
        """Charge les donn√©es persistantes depuis la base"""
        try:
            # Chargement des datasets et mod√®les depuis la DB
            datasets = self.annotation_manager.get_datasets()
            models = self.annotation_manager.get_trained_models()
            
            print(f"üîÑ Chargement donn√©es persistantes:")
            print(f"üìä Datasets: {len(datasets)}")
            print(f"ü§ñ Mod√®les: {len(models)}")
            
            # Logs d√©taill√©s des mod√®les disponibles
            for model in models:
                print(f"  ‚Ä¢ {model['name']} ‚Üí classes: {model['class_names']}")
                
        except Exception as e:
            print(f"‚ùå Erreur chargement donn√©es persistantes: {e}")

    def update_interface_state(self):
        """Met √† jour l'√©tat g√©n√©ral de l'interface"""
        has_classes = bool(self.object_classes)
        has_active_class = self.current_class is not None
        
        # NOUVEAUT√â: Utilisation de la persistance DB
        trained_models = self.annotation_manager.get_trained_models()
        has_trained_models = bool(trained_models)
        
        # DEBUG: Affichage des √©tats pour diagnostiquer
        print(f"üîç Mise √† jour interface - Classes: {has_classes}, Active: {has_active_class}, Mod√®les: {has_trained_models}")
        print(f"üîç Mod√®les disponibles: {[m['name'] for m in trained_models]}")
        
        # Activation/d√©sactivation des contr√¥les
        self.start_annotation_btn.setEnabled(has_active_class)
        self.train_btn.setEnabled(has_classes)
        # CORRECTION: Activer le bouton d√©tection si des mod√®les sont disponibles
        self.detect_btn.setEnabled(has_trained_models)
        
        # DEBUG: V√©rification de l'√©tat du bouton
        print(f"üîç Bouton d√©tection activ√©: {self.detect_btn.isEnabled()}")
        
        # Mise √† jour de la liste des mod√®les si n√©cessaire
        if has_trained_models:
            self._update_detection_models_list()
        
        # Mise √† jour du statut
        if not has_classes:
            self.status_label.setText("üìù Cr√©ez votre premi√®re classe d'objet pour commencer")
        elif not has_active_class:
            self.status_label.setText("üéØ S√©lectionnez une classe pour commencer l'annotation")
        else:
            examples_count = len(self.object_classes[self.current_class]['examples'])
            if examples_count < 10:
                self.status_label.setText(f"üìä {examples_count}/10 exemples minimum - Continuez l'annotation")
            else:
                self.status_label.setText(f"‚úÖ {examples_count} exemples - Pr√™t pour l'entra√Ænement")
    
    def on_class_selection_changed(self):
        """Gestion du changement de s√©lection de classe"""
        current_item = self.classes_tree.currentItem()
        
        if current_item:
            class_name = current_item.text(0)
            self.current_class = class_name
            
            # Mise √† jour des combos
            self.active_class_combo.setCurrentText(class_name)
            
            # Mise √† jour des progressions et listes
            self.update_annotation_progress()
            self.update_examples_list()
        else:
            self.current_class = None
            
        self.update_interface_state()
    
    def toggle_annotation_mode(self, checked):
        """Active/d√©sactive le mode annotation"""
        if checked:
            if not self.current_class:
                QMessageBox.warning(self, "Attention", "Veuillez s√©lectionner une classe d'objet avant de commencer l'annotation.")
                self.start_annotation_btn.setChecked(False)
                return
            
            if not ANNOTATION_TOOL_AVAILABLE or not self.annotation_tool:
                QMessageBox.critical(self, "Erreur", "Outil d'annotation non disponible.")
                self.start_annotation_btn.setChecked(False)
                return
                
            # Activation de l'outil d'annotation
            try:
                self.annotation_tool.set_active_class(self.current_class)
                mode = 'bbox' if self.bbox_mode_btn.isChecked() else 'polygon'
                self.annotation_tool.set_annotation_mode(mode)
                
                # Activation dans QGIS
                self.iface.mapCanvas().setMapTool(self.annotation_tool)
                
                self.status_label.setText(f"üéØ Mode annotation actif - Classe: {self.current_class} | Cliquez et glissez pour dessiner des rectangles autour des objets")
                self.start_annotation_btn.setText("‚è∏Ô∏è Arr√™ter l'Annotation")
                
            except Exception as e:
                error_msg = f"Erreur lors de l'activation de l'outil d'annotation:\n{str(e)}"
                QMessageBox.critical(self, "Erreur d'Activation", error_msg)
                self.start_annotation_btn.setChecked(False)
                
        else:
            # D√©sactivation de l'outil
            if self.annotation_tool:
                self.iface.mapCanvas().unsetMapTool(self.annotation_tool)
            
            self.status_label.setText("‚èπÔ∏è Mode annotation arr√™t√©")
            self.start_annotation_btn.setText("üéØ Commencer l'Annotation")
    
    def on_annotation_mode_changed(self):
        """Gestion du changement de mode d'annotation"""
        if self.bbox_mode_btn.isChecked():
            self.polygon_mode_btn.setChecked(False)
        elif self.polygon_mode_btn.isChecked():
            self.bbox_mode_btn.setChecked(False)
        else:
            # Au moins un mode doit √™tre s√©lectionn√©
            self.bbox_mode_btn.setChecked(True)
    
    def start_training(self):
        """Lance la g√©n√©ration de dataset ou l'entra√Ænement selon le contexte"""
        
        # Si nous avons d√©j√† un dataset et que le bouton dit "Lancer Entra√Ænement"
        if (self.current_dataset_info and 
            self.train_btn.text() == "üß† Lancer Entra√Ænement"):
            self._start_actual_training(self.current_dataset_info)
            return
        
        # Sinon, proc√©dure normale de g√©n√©ration de dataset
        selected_class = self.training_class_combo.currentText()
        
        if selected_class.startswith("---"):
            QMessageBox.warning(self, "Attention", "Veuillez s√©lectionner une classe √† entra√Æner.")
            return
        
        if not self.dataset_generator:
            QMessageBox.critical(self, "Erreur", "G√©n√©rateur de datasets non disponible.")
            return
        
        # V√©rification des donn√©es
        if self.annotation_manager:
            stats = self.annotation_manager.get_class_statistics(selected_class)
            if not stats.ready_for_training:
                reply = QMessageBox.question(
                    self, 
                    "Donn√©es Insuffisantes", 
                    f"La classe '{selected_class}' n'a que {stats.example_count} exemples.\n"
                    f"Minimum recommand√© : 10 exemples de qualit√©.\n"
                    f"Score qualit√© actuel : {stats.quality_score:.1%}\n\n"
                    f"Continuer quand m√™me ?",
                    QMessageBox.Yes | QMessageBox.No
                )
                if reply != QMessageBox.Yes:
                    return
        
        # Dialog de configuration du dataset
        try:
            dataset_name = f"dataset_{selected_class}_{datetime.now().strftime('%Y%m%d_%H%M')}"
            
            # V√©rification du type de g√©n√©rateur pour adapter le message
            has_augmentation = hasattr(self.dataset_generator, 'augmentation_config')
            
            if has_augmentation:
                # Configuration d'augmentation compl√®te
                from ..core.yolo_dataset_generator import AugmentationConfig
                aug_config = AugmentationConfig(
                    enabled=True,
                    augmentation_factor=3
                )
                
                message = (f"G√©n√©ration du dataset d'entra√Ænement pour '{selected_class}':\n\n"
                          f"‚Ä¢ G√©n√©rateur: Complet avec augmentation\n"
                          f"‚Ä¢ Augmentation de donn√©es: Activ√©e (3x multiplicateur)\n"
                          f"‚Ä¢ Division: 70% train / 20% val / 10% test\n"
                          f"‚Ä¢ Format: YOLO standard\n\n"
                          f"Continuer ?")
            else:
                # G√©n√©rateur simplifi√©
                aug_config = None
                message = (f"G√©n√©ration du dataset d'entra√Ænement pour '{selected_class}':\n\n"
                          f"‚Ä¢ G√©n√©rateur: Simplifi√© (sans augmentation)\n"
                          f"‚Ä¢ Augmentation de donn√©es: Non disponible\n"
                          f"‚Ä¢ Division: 70% train / 20% val / 10% test\n"
                          f"‚Ä¢ Format: YOLO standard\n\n"
                          f"Continuer ?")
            
            # Message de confirmation
            reply = QMessageBox.question(
                self,
                "G√©n√©ration du Dataset",
                message,
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                # Lancement de la g√©n√©ration
                self.train_btn.setEnabled(False)
                self.train_btn.setText("üîÑ G√©n√©ration en cours...")
                self.training_progress.setVisible(True)
                self.training_progress.setRange(0, 0)  # Mode ind√©termin√©
                
                # G√©n√©ration asynchrone
                from qgis.PyQt.QtCore import QTimer
                QTimer.singleShot(100, lambda: self._generate_dataset_for_training(
                    dataset_name, [selected_class], aug_config
                ))
                
        except Exception as e:
            QMessageBox.critical(self, "Erreur", f"Erreur lors de la pr√©paration : {str(e)}")
    
    def _generate_dataset_for_training(self, dataset_name: str, selected_classes: list, aug_config):
        """G√©n√®re le dataset en arri√®re-plan"""
        try:
            # Adaptation selon le type de g√©n√©rateur
            if hasattr(self.dataset_generator, 'augmentation_config') and aug_config:
                # G√©n√©rateur complet avec augmentation
                dataset_info = self.dataset_generator.generate_dataset(
                    dataset_name=dataset_name,
                    selected_classes=selected_classes,
                    augmentation_config=aug_config
                )
            else:
                # G√©n√©rateur simplifi√©
                dataset_info = self.dataset_generator.generate_dataset(
                    dataset_name=dataset_name,
                    selected_classes=selected_classes
                )
            # Le succ√®s sera g√©r√© par le signal dataset_generation_completed
            
        except Exception as e:
            self.dataset_generator.dataset_generation_error.emit(dataset_name, str(e))
    
    def start_detection(self):
        """D√©marre la d√©tection d'objets sur le raster actif"""
        
        # CORRECTION: V√©rifications pr√©alables plus flexibles
        print(f"üîç D√©but d√©tection - YOLOEngine disponible: {self.yolo_engine is not None}")
        trained_models = self.annotation_manager.get_trained_models()
        print(f"üîç Mod√®les entra√Æn√©s disponibles: {len(trained_models)}")
        
        # V√©rification absolue du YOLOEngine
        if not self.yolo_engine:
            QMessageBox.critical(self, "Erreur", 
                "YOLOEngine non disponible. V√©rifiez l'installation des d√©pendances:\n"
                "- PyTorch\n"
                "- Ultralytics\n"
                "- OpenCV\n\n"
                "Utilisez le gestionnaire de d√©pendances pour les installer.")
            return
        
        # NOUVEAUT√â: D√©tection du mode de s√©lection (classe ou mod√®le)
        selected_class = self.detection_class_combo.currentData()
        selected_model_text = self.detection_model_combo.currentText()
        
        model_data = None
        detection_mode = None
        
        # Priorit√© 1: S√©lection par classe
        if selected_class and not selected_class.startswith("---"):
            model = self.get_model_for_class(selected_class)
            if model:
                model_data = model['id']  # Utilise l'ID du mod√®le
                model_path = model['path']
                detection_mode = f"classe '{selected_class}'"
                print(f"üéØ D√©tection par classe: {selected_class} ‚Üí mod√®le: {model['name']}")
            else:
                QMessageBox.warning(self, "Erreur", f"Aucun mod√®le disponible pour la classe '{selected_class}'")
                return
        
        # Priorit√© 2: S√©lection par mod√®le (mode expert)
        elif not selected_model_text.startswith("---"):
            model_id = self.detection_model_combo.currentData()
            if model_id:
                # Trouver le mod√®le par ID
                trained_models = self.annotation_manager.get_trained_models()
                model = next((m for m in trained_models if m['id'] == model_id), None)
                if model:
                    model_data = model['id']
                    model_path = model['path']
                    detection_mode = f"mod√®le '{model['name']}'"
                    print(f"üîß D√©tection par mod√®le expert: {model['name']}")
                else:
                    QMessageBox.warning(self, "Erreur", f"Mod√®le non trouv√©: {model_id}")
                    return
            else:
                QMessageBox.warning(self, "Erreur", "S√©lection de mod√®le invalide")
                return
        
        # Aucune s√©lection valide
        else:
            # Auto-s√©lection si une seule classe/mod√®le disponible
            available_classes = self.get_available_classes_with_models()
            trained_models = self.annotation_manager.get_trained_models()
            
            if len(available_classes) == 1:
                selected_class = available_classes[0]
                model = self.get_model_for_class(selected_class)
                if model:
                    model_data = model['id']
                    model_path = model['path']
                    detection_mode = f"classe '{selected_class}' (auto-s√©lection)"
                    print(f"üîÑ Auto-s√©lection: {detection_mode}")
                else:
                    QMessageBox.warning(self, "Erreur", "Mod√®le auto-s√©lectionn√© introuvable")
                    return
            elif len(trained_models) == 1:
                model = trained_models[0]
                model_data = model['id']
                model_path = model['path']
                detection_mode = f"mod√®le '{model['name']}' (auto-s√©lection)"
                print(f"üîÑ Auto-s√©lection: {detection_mode}")
            else:
                QMessageBox.warning(self, "Attention", 
                    "Veuillez s√©lectionner:\n"
                    "‚Ä¢ Une classe d'objet √† d√©tecter, OU\n"
                    "‚Ä¢ Un mod√®le sp√©cifique (mode expert)")
                return
        
        # V√©rification finale du chemin du mod√®le
        if not model_data or not model_path:
            QMessageBox.warning(self, "Erreur", "Informations de mod√®le incompl√®tes")
            return
        
        print(f"üîç Mode de d√©tection: {detection_mode}")
        print(f"üîç Chemin mod√®le: {model_path}")
        
        # CORRECTION: V√©rification intelligente de l'existence du mod√®le
        if not os.path.exists(model_path):
            QMessageBox.critical(self, "Erreur", f"Fichier mod√®le non trouv√© :\n{model_path}")
            return
        
        # Diagnostic complet de l'√©tat du syst√®me
        print("üîç === DIAGNOSTIC D√âTECTION ===")
        
        # V√©rification du canvas
        canvas = self.iface.mapCanvas()
        print(f"üîç Canvas: {canvas}")
        print(f"üîç Canvas layers: {canvas.layerCount()}")
        
        # V√©rification de la couche raster active
        active_layer = canvas.currentLayer()
        print(f"üîç Couche active: {active_layer}")
        print(f"üîç Type couche active: {type(active_layer)}")
        
        from qgis.core import QgsRasterLayer, QgsProject
        
        # Liste toutes les couches du projet
        project_layers = QgsProject.instance().mapLayers()
        raster_layers = [layer for layer in project_layers.values() if isinstance(layer, QgsRasterLayer)]
        print(f"üîç Couches raster dans le projet: {len(raster_layers)}")
        for i, layer in enumerate(raster_layers):
            print(f"  {i+1}. {layer.name()} - Valide: {layer.isValid()}")
        
        if not isinstance(active_layer, QgsRasterLayer):
            if len(raster_layers) > 0:
                # Utiliser la premi√®re couche raster disponible
                active_layer = raster_layers[0]
                print(f"üîç Utilisation automatique de: {active_layer.name()}")
                QMessageBox.information(self, "Couche S√©lectionn√©e",
                    f"Aucune couche raster active d√©tect√©e.\n"
                    f"Utilisation automatique de: {active_layer.name()}")
            else:
                QMessageBox.warning(self, "Couche Manquante",
                    "Aucune couche raster trouv√©e dans le projet.\n"
                    "Veuillez charger une couche raster (GeoTIFF, etc.) pour lancer la d√©tection.")
                return
        
        # V√©rifications de validit√© de la couche
        if not active_layer.isValid():
            QMessageBox.critical(self, "Couche Invalide",
                f"La couche raster '{active_layer.name()}' n'est pas valide.\n"
                f"V√©rifiez que le fichier source existe et est accessible.")
            return
        
        print(f"üîç Couche finale s√©lectionn√©e: {active_layer.name()}")
        print(f"üîç √âtendue couche: {active_layer.extent()}")
        print(f"üîç CRS couche: {active_layer.crs().authid()}")
        
        # Configuration de la d√©tection
        confidence = self.confidence_slider.value() / 100.0  # Conversion 0-100 -> 0.0-1.0
        
        # D√©termination de la zone √† traiter
        if self.current_view_radio.isChecked():
            extent = self.iface.mapCanvas().extent()
            zone_description = "vue actuelle du canvas"
        elif self.full_layer_radio.isChecked():
            extent = active_layer.extent()
            zone_description = "couche compl√®te"
        else:  # custom_extent_radio
            extent = self.iface.mapCanvas().extent()  # Pour l'instant, comme current_view
            zone_description = "emprise personnalis√©e"
        
        # Confirmation avant lancement
        reply = QMessageBox.question(
            self,
            "Lancer la D√©tection",
            f"üîç Param√®tres de d√©tection :\n\n"
            f"‚Ä¢ Mod√®le : {model_data}\n"
            f"‚Ä¢ Couche : {active_layer.name()}\n"
            f"‚Ä¢ Zone : {zone_description}\n"
            f"‚Ä¢ Seuil confiance : {confidence:.1%}\n\n"
            f"Lancer la d√©tection ?",
            QMessageBox.Yes | QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self._run_detection(active_layer, model_path, extent, confidence, zone_description)
    
    def update_confidence_label(self, value):
        """Met √† jour le label du seuil de confiance"""
        confidence = value / 100.0
        self.confidence_label.setText(f"{confidence:.2f}")
    
    def update_scale_info(self, class_name: str):
        """Met √† jour les informations d'√©chelle pour une classe"""
        try:
            stats = self.annotation_manager.get_class_statistics(class_name)
            
            if stats.example_count == 0:
                self.scale_info_label.setText(f"‚ùå Aucun exemple d'entra√Ænement pour '{class_name}'")
                return
            
            # Formatage des informations d'√©chelle
            info_text = f"üìä <b>{class_name}</b> ({stats.example_count} exemples)<br/>"
            
            if stats.optimal_pixel_size > 0:
                info_text += f"üéØ <b>R√©solution optimale:</b> {stats.optimal_pixel_size:.3f} m/pixel<br/>"
                info_text += f"üìê <b>Plage d'√©chelles:</b> 1:{stats.scale_range[0]:,} - 1:{stats.scale_range[1]:,}<br/>"
                info_text += f"üîç <b>Zoom QGIS:</b> niveau {stats.zoom_level_range[0]} - {stats.zoom_level_range[1]}<br/>"
                
                # Indication de coh√©rence
                scale_variance = stats.pixel_size_range[1] / stats.pixel_size_range[0] if stats.pixel_size_range[0] > 0 else float('inf')
                if scale_variance < 1.5:
                    info_text += f"‚úÖ <b>Coh√©rence:</b> Excellente (variance {scale_variance:.1f}x)"
                elif scale_variance < 2.5:
                    info_text += f"‚ö†Ô∏è <b>Coh√©rence:</b> Bonne (variance {scale_variance:.1f}x)"
                else:
                    info_text += f"‚ùå <b>Coh√©rence:</b> Faible (variance {scale_variance:.1f}x)"
            else:
                info_text += "‚ö†Ô∏è Donn√©es d'√©chelle incompl√®tes"
            
            self.scale_info_label.setText(info_text)
            
        except Exception as e:
            print(f"‚ùå Erreur mise √† jour infos √©chelle: {e}")
            self.scale_info_label.setText(f"‚ùå Erreur r√©cup√©ration donn√©es pour '{class_name}'")
    
    def on_detection_class_index_changed(self, index):
        """Gestion du changement de classe de d√©tection par index"""
        if index <= 0:  # Index 0 = "--- S√©lectionner une classe ---"
            self.detect_btn.setEnabled(False)
            self.status_label.setText("‚ùå Aucune classe s√©lectionn√©e")
            self.scale_info_label.setText("S√©lectionner une classe pour voir les informations d'√©chelle")
            return
        
        # R√©cup√©ration du vrai nom de classe depuis itemData()
        class_name = self.detection_class_combo.itemData(index)
        display_name = self.detection_class_combo.itemText(index)
        
        if class_name:
            print(f"üéØ Classe s√©lectionn√©e: '{class_name}' (affich√©: '{display_name}')")
            model = self.get_model_for_class(class_name)
            if model:
                print(f"‚úÖ Mod√®le trouv√©: '{model['name']}'")
                
            # NOUVEAUT√â: Mise √† jour des informations d'√©chelle
            self.update_scale_info(class_name)
            
            # Synchroniser la s√©lection du mod√®le expert
            if model:
                model_id = model['id']
                for i in range(self.detection_model_combo.count()):
                    if self.detection_model_combo.itemData(i) == model_id:
                        self.detection_model_combo.setCurrentIndex(i)
                        break
                
                # Activer le bouton de d√©tection
                self.detect_btn.setEnabled(True)
                self.status_label.setText(f"üéØ Pr√™t √† d√©tecter: {class_name}")
            else:
                print(f"‚ö†Ô∏è Aucun mod√®le disponible pour la classe '{class_name}'")
                self.detect_btn.setEnabled(False)
                self.status_label.setText(f"‚ùå Aucun mod√®le entra√Æn√© pour: {class_name}")
    
    def on_tab_changed(self, index):
        """Gestion du changement d'onglet"""
        tab_names = ["Classes", "Annotation", "Entra√Ænement", "D√©tection"]
        if index < len(tab_names):
            self.status_label.setText(f"üìÇ Onglet {tab_names[index]} actif")
            
            # CORRECTION: Si on acc√®de √† l'onglet d√©tection, mettre √† jour les listes
            if index == 3:  # Index 3 = onglet d√©tection
                print("üîç Acc√®s onglet d√©tection - Mise √† jour des listes")
                self._update_detection_models_list()  # IMPORTANT: Mettre √† jour les dropdowns
                trained_models = self.annotation_manager.get_trained_models()
                if trained_models:
                    print("üîç Mod√®les trouv√©s - Activation du bouton")
                    self.detect_btn.setEnabled(True)
                else:
                    print("‚ö†Ô∏è Aucun mod√®le trouv√©")
                self.update_interface_state()
    
    def show_help(self):
        """Affiche l'aide"""
        help_text = """
        <h3>üéØ YOLO Interactive Object Detector - Guide Rapide</h3>
        
        <h4>1. üìÅ Cr√©er des Classes d'Objets</h4>
        <p>‚Ä¢ D√©finissez le type d'objet √† d√©tecter (ex: "Poteaux √©lectriques")<br>
        ‚Ä¢ Une description optionnelle aide √† clarifier l'objectif</p>
        
        <h4>2. üéØ Annoter des Exemples</h4>
        <p>‚Ä¢ S√©lectionnez une classe active<br>
        ‚Ä¢ Activez le mode annotation<br>
        ‚Ä¢ Cliquez sur 10-20 exemples d'objets sur le canvas QGIS</p>
        
        <h4>3. üß† Entra√Æner le Mod√®le</h4>
        <p>‚Ä¢ Choisissez la classe √† entra√Æner<br>
        ‚Ä¢ Ajustez les param√®tres si n√©cessaire<br>
        ‚Ä¢ Lancez l'entra√Ænement (quelques minutes)</p>
        
        <h4>4. üîç D√©tecter Massivement</h4>
        <p>‚Ä¢ S√©lectionnez le mod√®le entra√Æn√©<br>
        ‚Ä¢ D√©finissez la zone de traitement<br>
        ‚Ä¢ Lancez la d√©tection automatique</p>
        
        <p><b>üí° Astuce :</b> Plus vous fournissez d'exemples vari√©s, meilleur sera le mod√®le !</p>
        """
        
        QMessageBox.information(self, "Aide", help_text)
    
    def show_settings(self):
        """Affiche les param√®tres"""
        QMessageBox.information(self, "Param√®tres", "Interface de param√®tres en cours de d√©veloppement...")
    
    def show_dependency_manager(self):
        """Affiche le gestionnaire de d√©pendances"""
        if DEPENDENCY_MANAGER_AVAILABLE:
            show_dependency_manager(self)
        else:
            QMessageBox.warning(self, "Gestionnaire non disponible", 
                              "Le gestionnaire de d√©pendances n'est pas disponible.")
    
    def on_annotation_created(self, annotation_data):
        """
        Gestion d'une nouvelle annotation cr√©√©e
        
        Args:
            annotation_data: Donn√©es de l'annotation
        """
        try:
            class_name = annotation_data.get('class_name')
            if class_name in self.object_classes:
                # Ajout de l'exemple √† la classe
                self.object_classes[class_name]['examples'].append(annotation_data)
                
                # Mise √† jour de l'interface
                self.update_annotation_progress()
                self.update_classes_tree()
                
                # Mise √† jour de la liste des exemples
                self.update_examples_list()
                
                # Message de succ√®s
                examples_count = len(self.object_classes[class_name]['examples'])
                self.status_label.setText(
                    f"‚úÖ Exemple #{examples_count} ajout√© √† '{class_name}'"
                )
                
        except Exception as e:
            QMessageBox.critical(self, "Erreur", f"Erreur lors de l'ajout de l'exemple:\n{str(e)}")
    
    def on_annotation_tool_activated(self):
        """Outil d'annotation activ√©"""
        if hasattr(self, 'status_label'):
            self.status_label.setText("üéØ Outil d'annotation activ√© sur le canvas")
    
    def on_annotation_tool_deactivated(self):
        """Outil d'annotation d√©sactiv√©"""
        # Synchronisation avec l'interface
        if self.start_annotation_btn.isChecked():
            self.start_annotation_btn.setChecked(False)
    
    def on_annotation_added(self, class_name: str, annotation_data: dict):
        """Gestion de l'ajout d'une nouvelle annotation via le gestionnaire"""
        print(f"üìä Nouvelle annotation ajout√©e pour '{class_name}'")
        
        # Mise √† jour de l'affichage si c'est la classe active
        if class_name == self.current_class:
            self.update_annotation_progress()
            self.update_examples_list()
    
    def on_statistics_updated(self, class_name: str, stats_data: dict):
        """Gestion de la mise √† jour des statistiques"""
        print(f"üìà Statistiques mises √† jour pour '{class_name}': {stats_data['example_count']} exemples")
        
        # Mise √† jour de l'arbre des classes
        self.update_classes_tree_with_real_stats()
        
        # Mise √† jour de l'interface si c'est la classe active
        if class_name == self.current_class:
            self.update_annotation_progress()
    
    def update_classes_tree_with_real_stats(self):
        """Met √† jour l'arbre des classes avec les vraies statistiques"""
        if not self.annotation_manager:
            print("‚ö†Ô∏è AnnotationManager non disponible pour les statistiques")
            # Fallback vers m√©thode basique
            self.update_classes_tree()
            return
            
        try:
            print("üîÑ Mise √† jour arbre des classes avec statistiques r√©elles...")
            
            # R√©cup√©ration de toutes les classes avec annotations
            classes_with_annotations = self.annotation_manager.get_all_classes()
            print(f"üìä Classes dans la base: {classes_with_annotations}")
            
            # Ajout des classes sans annotations (seulement dans self.object_classes)
            all_classes = set(self.object_classes.keys()) | set(classes_with_annotations)
            print(f"üìã Toutes les classes √† afficher: {sorted(all_classes)}")
            
            self.classes_tree.clear()
            
            items_added = 0
            for class_name in sorted(all_classes):
                try:
                    stats = self.annotation_manager.get_class_statistics(class_name)
                    
                    # Statut bas√© sur les vraies statistiques
                    if stats.ready_for_training:
                        status = "‚úÖ Pr√™t"
                    elif stats.example_count > 0:
                        status = f"‚ö†Ô∏è {stats.example_count}/10"
                    else:
                        status = "‚≠ï Vide"
                    
                    # Score qualit√©
                    quality = f"{stats.quality_score:.1%}" if stats.example_count > 0 else "0%"
                    
                    item = QTreeWidgetItem([
                        class_name,
                        str(stats.example_count),
                        status,
                        quality
                    ])
                    
                    # Couleur selon le statut
                    if stats.ready_for_training:
                        item.setForeground(2, item.foreground(2))  # Vert par d√©faut
                    elif stats.example_count > 0:
                        from qgis.PyQt.QtGui import QColor
                        item.setForeground(2, QColor(255, 165, 0))  # Orange
                    
                    self.classes_tree.addTopLevelItem(item)
                    items_added += 1
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Erreur statistiques pour classe '{class_name}': {e}")
                    # Ajouter quand m√™me la classe avec des infos basiques
                    item = QTreeWidgetItem([
                        class_name,
                        "?",
                        "‚ùì Erreur",
                        "0%"
                    ])
                    self.classes_tree.addTopLevelItem(item)
                    items_added += 1
            
            print(f"‚úÖ {items_added} classes ajout√©es √† l'arbre")
            
            # Force le rafra√Æchissement de l'affichage
            self.classes_tree.update()
                
        except Exception as e:
            print(f"‚ùå Erreur mise √† jour arbre : {e}")
            import traceback
            traceback.print_exc()
            # Fallback vers l'ancienne m√©thode
            self.update_classes_tree()
    
    def on_dataset_generation_started(self, dataset_name: str):
        """Gestion du d√©but de g√©n√©ration de dataset"""
        self.training_logs.append(f"üìä D√©but de g√©n√©ration du dataset '{dataset_name}'...")
        print(f"üìä G√©n√©ration dataset d√©marr√©e : {dataset_name}")
    
    def on_dataset_generation_progress(self, class_name: str, current: int, total: int):
        """Gestion du progr√®s de g√©n√©ration"""
        progress_msg = f"üîÑ Traitement classe '{class_name}' ({current}/{total})"
        self.training_logs.append(progress_msg)
        print(progress_msg)
    
    def on_dataset_generation_completed(self, dataset_name: str, dataset_info: dict):
        """Gestion de la fin de g√©n√©ration de dataset"""
        success_msg = (f"‚úÖ Dataset '{dataset_name}' g√©n√©r√© avec succ√®s !\n"
                      f"‚Ä¢ {dataset_info['total_images']} images totales\n"
                      f"‚Ä¢ Train: {dataset_info['train_images']} | "
                      f"Val: {dataset_info['val_images']} | "
                      f"Test: {dataset_info['test_images']}")
        
        self.training_logs.append(success_msg)
        
        # Stockage des informations dataset pour l'entra√Ænement
        self.current_dataset_info = dataset_info
        
        # R√©initialisation de l'interface de g√©n√©ration
        self.training_progress.setVisible(False)
        
        # Proposition d'entra√Ænement si YOLOEngine disponible
        if self.yolo_engine:
            reply = QMessageBox.question(
                self,
                "Dataset Pr√™t - Lancer l'Entra√Ænement ?",
                f"Dataset '{dataset_name}' g√©n√©r√© avec succ√®s !\n\n"
                f"‚Ä¢ {dataset_info['total_images']} images g√©n√©r√©es\n"
                f"‚Ä¢ Chemin : {dataset_info['dataset_path']}\n\n"
                f"üß† Lancer l'entra√Ænement du mod√®le YOLO maintenant ?",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                # Lancer l'entra√Ænement directement
                self._start_actual_training(dataset_info)
            else:
                # L'utilisateur peut lancer l'entra√Ænement plus tard
                self.train_btn.setText("üß† Lancer Entra√Ænement")
                self.train_btn.setEnabled(True)
                self.status_label.setText(f"‚úÖ Dataset pr√™t - Cliquez pour entra√Æner le mod√®le")
        else:
            # Pas de YOLOEngine - retour √† l'√©tat initial
            self.train_btn.setText("üöÄ G√©n√©rer Dataset")
            self.train_btn.setEnabled(True)
            
            QMessageBox.information(
                self,
                "Dataset G√©n√©r√©",
                f"Dataset '{dataset_name}' cr√©√© avec succ√®s !\n\n"
                f"Images g√©n√©r√©es : {dataset_info['total_images']}\n"
                f"Chemin : {dataset_info['dataset_path']}\n\n"
                f"‚ö†Ô∏è YOLOEngine non disponible - Impossible de lancer l'entra√Ænement."
            )
            
            self.status_label.setText(f"‚úÖ Dataset g√©n√©r√© - YOLOEngine requis pour entra√Ænement")
        
        print(f"‚úÖ Dataset g√©n√©r√© : {dataset_name}")
    
    def on_dataset_generation_error(self, dataset_name: str, error_message: str):
        """Gestion des erreurs de g√©n√©ration"""
        error_msg = f"‚ùå Erreur g√©n√©ration dataset '{dataset_name}': {error_message}"
        self.training_logs.append(error_msg)
        
        # R√©initialisation de l'interface
        self.training_progress.setVisible(False)
        self.train_btn.setEnabled(True)
        self.train_btn.setText("üöÄ G√©n√©rer Dataset")
        
        # Message d'erreur
        QMessageBox.critical(
            self,
            "Erreur de G√©n√©ration",
            f"√âchec de la g√©n√©ration du dataset '{dataset_name}':\n\n{error_message}"
        )
        
        self.status_label.setText("‚ùå Erreur g√©n√©ration dataset")
        print(f"‚ùå Erreur g√©n√©ration dataset : {error_message}")
    
    def update_annotation_progress(self):
        """Met √† jour la barre de progression d'annotation"""
        if not self.current_class:
            self.annotation_progress.setValue(0)
            self.stats_label.setText("üìà Aucune classe s√©lectionn√©e")
            return
        
        # Utilisation des vraies statistiques si disponibles
        if self.annotation_manager:
            try:
                stats = self.annotation_manager.get_class_statistics(self.current_class)
                examples_count = stats.example_count
                quality_score = stats.quality_score
                ready_for_training = stats.ready_for_training
            except Exception as e:
                print(f"‚ùå Erreur r√©cup√©ration stats : {e}")
                examples_count = 0
                quality_score = 0.0
                ready_for_training = False
        else:
            # Fallback vers anciennes donn√©es
            if self.current_class in self.object_classes:
                examples_count = len(self.object_classes[self.current_class]['examples'])
            else:
                examples_count = 0
            quality_score = 0.0
            ready_for_training = examples_count >= 10
        
        # Mise √† jour de la barre de progression
        self.annotation_progress.setValue(min(examples_count, 20))  # Max 20 pour l'affichage
        
        # Mise √† jour du texte de statut avec qualit√©
        if ready_for_training:
            self.stats_label.setText(f"‚úÖ {examples_count} exemples - Qualit√©: {quality_score:.1%} - Pr√™t pour l'entra√Ænement !")
        elif examples_count > 0:
            self.stats_label.setText(f"üìä {examples_count}/10 exemples - Qualit√©: {quality_score:.1%} - Continuez l'annotation")
        else:
            self.stats_label.setText("üìà Aucun exemple collect√© - Commencez l'annotation")
    
    def update_examples_list(self):
        """Met √† jour la liste des exemples"""
        self.examples_list.clear()
        
        if not self.current_class:
            return
        
        # Utiliser les vraies donn√©es de l'AnnotationManager si disponible
        examples = []
        if self.annotation_manager:
            try:
                examples = self.annotation_manager.get_class_annotations(self.current_class)
            except Exception as e:
                print(f"‚ùå Erreur r√©cup√©ration exemples : {e}")
                examples = []
        
        # Fallback vers les donn√©es locales si pas d'AnnotationManager
        if not examples and self.current_class in self.object_classes:
            examples = self.object_classes[self.current_class]['examples']
        
        for i, example in enumerate(examples):
            # Informations sur l'exemple
            if hasattr(example, 'timestamp'):
                # AnnotationExample object
                timestamp = example.timestamp
                dimensions = getattr(example, 'metadata', {}).get('dimensions_m', {})
                item_text = f"Exemple {example.id[:8]}... - {timestamp[:16]}"
            else:
                # Dict format (legacy)
                timestamp = example.get('timestamp', 'Inconnu')
                dimensions = example.get('dimensions_m', {})
                width = dimensions.get('width', 0)
                height = dimensions.get('height', 0)
                item_text = f"Exemple #{i+1} - {width:.1f}x{height:.1f}m - {timestamp[:16]}"
            
            # Ajout √† la liste
            item = QListWidgetItem(item_text)
            item.setData(Qt.UserRole, example)  # Stockage des donn√©es
            self.examples_list.addItem(item)
    
    def _start_actual_training(self, dataset_info: dict):
        """Lance l'entra√Ænement YOLO effectif"""
        if not self.yolo_engine:
            QMessageBox.critical(self, "Erreur", "YOLOEngine non disponible pour l'entra√Ænement.")
            return
        
        try:
            # R√©cup√©ration des param√®tres depuis l'interface
            base_model_text = self.base_model_combo.currentText()
            base_model = base_model_text.split()[0]  # "yolo11n.pt (Rapide, l√©ger)" -> "yolo11n.pt"
            epochs = self.epochs_spin.value()
            batch_size = self.batch_size_spin.value()
            learning_rate = self.learning_rate_spin.value()
            
            # Configuration pour l'entra√Ænement
            config = {
                'dataset_path': dataset_info['config_path'],
                'base_model': base_model,
                'epochs': epochs, 
                'batch_size': batch_size,
                'learning_rate': learning_rate,
                'dataset_name': dataset_info.get('name', 'unknown')
            }
            
            # Mise √† jour de l'interface pour l'entra√Ænement
            self.training_in_progress = True
            self.train_btn.setText("üß† Entra√Ænement en cours...")
            self.train_btn.setEnabled(False)
            self.training_progress.setVisible(True)
            self.training_progress.setRange(0, epochs)
            
            # Message de d√©but
            self.training_logs.append(f"üöÄ D√©but entra√Ænement YOLO avec {base_model}")
            self.training_logs.append(f"üìä Param√®tres: {epochs} √©poques, batch={batch_size}, lr={learning_rate}")
            
            # Lancement de l'entra√Ænement asynchrone
            from qgis.PyQt.QtCore import QTimer
            QTimer.singleShot(100, lambda: self._run_yolo_training_async(config))
            
        except Exception as e:
            QMessageBox.critical(self, "Erreur", f"Erreur lors du lancement de l'entra√Ænement:\n{str(e)}")
            self._reset_training_interface()
    
    def _run_yolo_training_async(self, config: dict):
        """Ex√©cute l'entra√Ænement YOLO de mani√®re asynchrone"""
        try:
            # Callback de progression
            def on_training_progress(progress: float, info: dict):
                epoch = info.get('epoch', 0)
                total_epochs = info.get('total_epochs', config['epochs'])
                loss = info.get('loss', 0.0)
                
                # Mise √† jour interface depuis le thread principal
                from qgis.PyQt.QtCore import QTimer
                QTimer.singleShot(0, lambda: self._update_training_progress(epoch, total_epochs, loss))
            
            # Lancement de l'entra√Ænement
            results = self.yolo_engine.train_custom_model(
                dataset_config_path=config['dataset_path'],
                base_model=config['base_model'],
                epochs=config['epochs'],
                batch_size=config['batch_size'],
                learning_rate=config['learning_rate'],
                progress_callback=on_training_progress
            )
            
            # Gestion du succ√®s
            from qgis.PyQt.QtCore import QTimer
            QTimer.singleShot(0, lambda: self._on_training_completed(results, config))
            
        except Exception as e:
            # Gestion de l'erreur
            error_message = str(e)  # Capturer le message d'erreur dans une variable locale
            from qgis.PyQt.QtCore import QTimer
            QTimer.singleShot(0, lambda: self._on_training_error(error_message))
    
    def _update_training_progress(self, epoch: int, total_epochs: int, loss: float):
        """Met √† jour la progression de l'entra√Ænement"""
        if self.training_progress.isVisible():
            self.training_progress.setValue(epoch)
            
            # Mise √† jour des logs de mani√®re limit√©e pour √©viter le spam
            if epoch % 5 == 0 or epoch == total_epochs:  # Log toutes les 5 √©poques
                self.training_logs.append(f"üìà √âpoque {epoch}/{total_epochs} - Loss: {loss:.4f}")
                
                # Auto-scroll vers le bas
                cursor = self.training_logs.textCursor()
                cursor.movePosition(cursor.End)
                self.training_logs.setTextCursor(cursor)
        
        # Mise √† jour du statut
        progress_percent = (epoch / total_epochs) * 100 if total_epochs > 0 else 0
        self.status_label.setText(f"üß† Entra√Ænement en cours... {progress_percent:.1f}% - √âpoque {epoch}/{total_epochs}")
    
    def _on_training_completed(self, results: dict, config: dict):
        """Gestion du succ√®s de l'entra√Ænement"""
        try:
            best_model_path = results.get('best_model_path', '')
            final_metrics = results.get('final_metrics', {})
            training_time = results.get('training_time', 0)
            
            # Messages de succ√®s
            self.training_logs.append("üéâ Entra√Ænement termin√© avec succ√®s !")
            self.training_logs.append(f"üíæ Mod√®le sauvegard√© : {best_model_path}")
            
            if training_time:
                self.training_logs.append(f"‚è±Ô∏è Temps d'entra√Ænement : {training_time:.1f}s")
            
            # Stockage du mod√®le entra√Æn√© avec lien direct aux classes
            classes_detected = list(config.get('class_names', {}).values())
            if not classes_detected:
                # CORRECTION: Si pas de classes d√©tect√©es, utiliser le nom du dataset
                dataset_name = config.get('dataset_name', 'Unknown')
                if 'dataset_' in dataset_name:
                    class_info = dataset_name.replace('dataset_', '').split('_')[0]
                else:
                    class_info = dataset_name
            elif len(classes_detected) == 1:
                class_info = classes_detected[0]
            elif len(classes_detected) <= 3:
                class_info = "_".join(classes_detected)
            else:
                class_info = f"{len(classes_detected)}Classes"
            
            model_name = f"{class_info}_Model_{datetime.now().strftime('%Y%m%d_%H%M')}"
            
            # CORRECTION: Copier le mod√®le vers un nom unique pour √©viter l'√©crasement
            import shutil
            unique_model_filename = f"{model_name}.pt"
            models_dir = self.annotation_manager.project_dir / "trained_models"
            models_dir.mkdir(parents=True, exist_ok=True)
            unique_model_path = models_dir / unique_model_filename
            
            try:
                # Copier le mod√®le temporaire vers l'emplacement permanent
                shutil.copy2(best_model_path, str(unique_model_path))
                print(f"üíæ Mod√®le copi√© vers: {unique_model_path}")
                final_model_path = str(unique_model_path)
            except Exception as copy_error:
                print(f"‚ö†Ô∏è Erreur copie mod√®le: {copy_error}, utilisation chemin original")
                final_model_path = best_model_path
            
            model_info = {
                'path': final_model_path,
                'dataset_name': config['dataset_name'],
                'classes': classes_detected,
                'created_at': datetime.now(),
                'metrics': final_metrics,
                'config': config
            }
            
            # NOUVEAUT√â: Sauvegarde en base de donn√©es
            dataset_id = config.get('dataset_name', f'dataset_{datetime.now().strftime("%Y%m%d_%H%M%S")}')
            
            # Si pas de classes d√©tect√©es, utiliser classe inf√©r√©e du dataset
            if not classes_detected:
                classes_detected = [class_info]
            
            # Sauvegarde du dataset si pas d√©j√† fait
            dataset_path = str(config.get('dataset_path', ''))
            if dataset_path:
                self.annotation_manager.save_dataset(
                    dataset_id=dataset_id,
                    name=config['dataset_name'],
                    path=dataset_path, 
                    class_names=classes_detected,
                    image_count=39,  # TODO: r√©cup√©rer le vrai nombre
                    config=config
                )
            
            # Sauvegarde du mod√®le entra√Æn√© en DB
            model_id = f"{model_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            success = self.annotation_manager.save_trained_model(
                model_id=model_id,
                name=model_name,
                path=final_model_path,
                dataset_id=dataset_id,
                class_names=classes_detected,
                metrics=final_metrics,
                config=config
            )
            
            if success:
                print(f"üíæ Mod√®le et dataset sauvegard√©s en DB")
            else:
                print(f"‚ö†Ô∏è Erreur sauvegarde en DB - continuit√© en m√©moire assur√©e")
            
            # Mise √† jour de l'interface
            self._reset_training_interface()
            self.train_btn.setText("‚úÖ Entra√Ænement Termin√©")
            
            # FORCER la mise √† jour de la liste des mod√®les pour la d√©tection
            print("üîÑ Force mise √† jour des listes de d√©tection apr√®s entra√Ænement")
            self._update_detection_models_list()
            
            # CORRECTION: Mise √† jour de l'√©tat de l'interface pour activer le bouton d√©tection
            self.update_interface_state()
            
            # CORRECTION SUPPL√âMENTAIRE: Force l'activation du bouton d√©tection
            trained_models = self.annotation_manager.get_trained_models()
            if trained_models:
                print("üîç Force activation du bouton d√©tection")
                self.detect_btn.setEnabled(True)
                self.detect_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #2E8B57;
                        color: white;
                        border: none;
                        border-radius: 5px;
                        padding: 8px;
                        font-weight: bold;
                    }
                    QPushButton:hover {
                        background-color: #228B22;
                    }
                """)
            
            # Message de succ√®s avec options
            reply = QMessageBox.question(
                self,
                "Entra√Ænement Termin√© !",
                f"üéâ Mod√®le YOLO entra√Æn√© avec succ√®s !\n\n"
                f"üìÅ Mod√®le : {model_name}\n"
                f"üíæ Sauvegard√© : {final_model_path}\n\n"
                f"üîç Passer √† l'onglet D√©tection pour tester le mod√®le ?",
                QMessageBox.Yes | QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                # Basculer vers l'onglet d√©tection
                self.tab_widget.setCurrentIndex(3)  # Index 3 = onglet d√©tection
                # S√©lectionner le mod√®le qui vient d'√™tre entra√Æn√©
                self.detection_model_combo.setCurrentText(model_name)
            
            self.status_label.setText(f"‚úÖ Mod√®le {model_name} entra√Æn√© - Pr√™t pour d√©tection")
            
        except Exception as e:
            print(f"Erreur traitement succ√®s entra√Ænement: {e}")
            self._on_training_error(f"Erreur post-entra√Ænement: {str(e)}")
    
    def _on_training_error(self, error_message: str):
        """Gestion des erreurs d'entra√Ænement"""
        self.training_logs.append(f"‚ùå Erreur entra√Ænement : {error_message}")
        
        # R√©initialisation interface
        self._reset_training_interface()
        
        # Message d'erreur
        QMessageBox.critical(
            self,
            "Erreur d'Entra√Ænement",
            f"L'entra√Ænement du mod√®le YOLO a √©chou√© :\n\n{error_message}\n\n"
            f"V√©rifiez les logs pour plus de d√©tails."
        )
        
        self.status_label.setText("‚ùå Erreur entra√Ænement - V√©rifiez les param√®tres")
    
    def _reset_training_interface(self):
        """Remet l'interface d'entra√Ænement √† l'√©tat initial"""
        self.training_in_progress = False
        self.train_btn.setEnabled(True)
        self.training_progress.setVisible(False)
        
        # Le texte du bouton sera mis √† jour par le contexte (g√©n√©ration ou nouvelle classe)
    
    def get_model_for_class(self, class_name):
        """R√©cup√®re le mod√®le entra√Æn√© pour une classe sp√©cifique"""
        models = self.annotation_manager.get_models_for_class(class_name)
        return models[0] if models else None
    
    def get_available_classes_with_models(self):
        """Retourne la liste des classes qui ont un mod√®le entra√Æn√©"""
        models = self.annotation_manager.get_trained_models()
        classes = set()
        for model in models:
            classes.update(model.get('class_names', []))
        return list(classes)
    
    def can_detect_for_class(self, class_name):
        """V√©rifie si on peut faire de la d√©tection pour une classe"""
        models = self.annotation_manager.get_models_for_class(class_name)
        return len(models) > 0
    
    def _update_detection_models_list(self):
        """Met √† jour la liste des mod√®les et classes dans l'onglet d√©tection"""
        print("üîÑ === MISE √Ä JOUR LISTES D√âTECTION ===")
        
        # Sauvegarder les s√©lections actuelles
        current_class_selection = self.detection_class_combo.currentText()
        current_model_selection = self.detection_model_combo.currentText()
        
        # NOUVEAUT√â: Donn√©es depuis la base
        trained_models = self.annotation_manager.get_trained_models()
        available_classes = self.get_available_classes_with_models()
        
        print(f"üìä Mod√®les en DB: {len(trained_models)}")
        print(f"üéØ Classes avec mod√®les: {len(available_classes)}")
        
        for model in trained_models:
            print(f"  ‚Ä¢ {model['name']} ‚Üí {model['class_names']} (path: {model['path']})")
        
        # MISE √Ä JOUR DES CLASSES DISPONIBLES
        self.detection_class_combo.clear()
        if not available_classes:
            self.detection_class_combo.addItem("--- Aucune classe entra√Æn√©e ---")
        else:
            self.detection_class_combo.addItem("--- S√©lectionner une classe ---")
            
            # Ajouter les classes avec mod√®les disponibles
            for class_name in sorted(available_classes):
                model = self.get_model_for_class(class_name)
                if model:
                    created_date = model['created_at']
                    if isinstance(created_date, str):
                        # Parse ISO format datetime
                        from datetime import datetime
                        try:
                            dt = datetime.fromisoformat(created_date.replace('Z', '+00:00'))
                            created_date = dt.strftime('%d/%m %H:%M')
                        except:
                            created_date = created_date[:16]  # Fallback
                    display_name = f"{class_name} (mod√®le du {created_date})"
                    self.detection_class_combo.addItem(display_name, class_name)
        
        # MISE √Ä JOUR DES MOD√àLES (mode expert)
        self.detection_model_combo.clear()
        if not trained_models:
            self.detection_model_combo.addItem("--- Aucun mod√®le entra√Æn√© ---")
        else:
            self.detection_model_combo.addItem("--- S√©lectionner un mod√®le ---")
            
            # Ajouter les mod√®les entra√Æn√©s (plus r√©cents en premier)
            for model in trained_models:
                model_name = model['name']
                created_date = model['created_at']
                if isinstance(created_date, str):
                    try:
                        from datetime import datetime
                        dt = datetime.fromisoformat(created_date.replace('Z', '+00:00'))
                        created_date = dt.strftime('%d/%m %H:%M')
                    except:
                        created_date = created_date[:16]
                
                classes_info = model.get('class_names', [])
                
                if classes_info:
                    if len(classes_info) == 1:
                        class_description = f"d√©tecte: {classes_info[0]}"
                    elif len(classes_info) <= 3:
                        class_description = f"d√©tecte: {', '.join(classes_info)}"
                    else:
                        class_description = f"d√©tecte {len(classes_info)} classes"
                else:
                    class_description = "mod√®le g√©n√©rique"
                
                display_name = f"{model_name} ({class_description}, {created_date})"
                self.detection_model_combo.addItem(display_name, model['id'])
        
        # Restaurer les s√©lections si possible
        if current_class_selection:
            for i in range(self.detection_class_combo.count()):
                if current_class_selection in self.detection_class_combo.itemText(i):
                    self.detection_class_combo.setCurrentIndex(i)
                    break
        
        if current_model_selection:
            index = self.detection_model_combo.findText(current_model_selection)
            if index >= 0:
                self.detection_model_combo.setCurrentIndex(index)
    
    def _run_detection(self, raster_layer, model_path: str, extent, confidence: float, zone_description: str):
        """Lance la d√©tection d'objets sur la zone sp√©cifi√©e"""
        try:
            # Chargement du mod√®le YOLO
            if not self.yolo_engine.load_model(model_path):
                QMessageBox.critical(self, "Erreur", f"Impossible de charger le mod√®le :\n{model_path}")
                return
            
            # Configuration de l'interface pour la d√©tection
            self.detect_btn.setText("üîç D√©tection en cours...")
            self.detect_btn.setEnabled(False)
            self.detection_progress.setVisible(True)
            self.detection_progress.setRange(0, 0)  # Mode ind√©termin√© au d√©but
            
            # Lancement de la d√©tection asynchrone
            from qgis.PyQt.QtCore import QTimer
            QTimer.singleShot(100, lambda: self._process_detection_async(
                raster_layer, extent, confidence, zone_description
            ))
            
        except Exception as e:
            QMessageBox.critical(self, "Erreur", f"Erreur lors du lancement de la d√©tection:\n{str(e)}")
            self._reset_detection_interface()
    
    def _process_detection_async(self, raster_layer, extent, confidence: float, zone_description: str):
        """Traite la d√©tection de mani√®re asynchrone par tiles avec optimisation d'√©chelle"""
        try:
            from ..core.raster_extractor import RasterPatchExtractor
            
            # NOUVEAUT√â: R√©cup√©ration m√©tadonn√©es d'√©chelle du mod√®le actuel
            optimal_pixel_size = None
            current_class = None
            
            # D√©terminer la classe/mod√®le utilis√© pour r√©cup√©rer ses m√©tadonn√©es
            if hasattr(self, 'detection_class_combo') and self.detection_class_combo.currentData():
                current_class = self.detection_class_combo.currentData()
                if current_class and not current_class.startswith("---"):
                    try:
                        stats = self.annotation_manager.get_class_statistics(current_class)
                        optimal_pixel_size = stats.optimal_pixel_size
                        print(f"üéØ CLASSE: {current_class}")
                        print(f"üéØ R√âSOLUTION OPTIMALE: {optimal_pixel_size:.3f}m/px")
                        print(f"üéØ PLAGE √âCHELLES: 1:{stats.scale_range[0]} - 1:{stats.scale_range[1]}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è Erreur m√©tadonn√©es classe: {e}")
            
            # Calcul des tiles pour traitement avec adaptation d'√©chelle
            tiles = self._calculate_detection_tiles(extent, raster_layer, 
                                                  max_tile_size=1024, 
                                                  optimal_pixel_size=optimal_pixel_size)
            total_tiles = len(tiles)
            
            if total_tiles == 0:
                self._on_detection_error("Aucune zone √† traiter")
                return
            
            # Mise √† jour de la barre de progression
            from qgis.PyQt.QtCore import QTimer
            QTimer.singleShot(0, lambda: self._update_detection_progress_setup(total_tiles))
            
            # Extracteur de patches
            extractor = RasterPatchExtractor(target_size=(640, 640))
            
            all_detections = []
            processed_tiles = 0
            
            for tile_extent in tiles:
                # Extraction du patch
                patch_data = extractor.extract_patch(tile_extent, raster_layer)
                
                if patch_data:
                    # D√©tection YOLO sur le patch
                    detections = self.yolo_engine.detect_objects(
                        patch_data['image_array'],
                        confidence_threshold=confidence
                    )
                    
                    # Conversion des coordonn√©es vers le syst√®me de la carte
                    map_detections = self._convert_detections_to_map_coords(
                        detections, patch_data, tile_extent
                    )
                    
                    all_detections.extend(map_detections)
                
                processed_tiles += 1
                
                # Mise √† jour de la progression
                QTimer.singleShot(0, lambda pt=processed_tiles, tt=total_tiles: 
                    self._update_detection_progress(pt, tt))
            
            # Finalisation
            QTimer.singleShot(0, lambda: self._on_detection_completed(
                all_detections, zone_description, total_tiles
            ))
            
        except Exception as e:
            from qgis.PyQt.QtCore import QTimer
            QTimer.singleShot(0, lambda: self._on_detection_error(str(e)))
    
    def _calculate_detection_tiles(self, extent, raster_layer, max_tile_size: int = 1024, 
                                  optimal_pixel_size: float = None):
        """
        Calcule les tiles pour la d√©tection avec adaptation d'√©chelle
        
        Args:
            extent: Zone √† traiter
            raster_layer: Couche raster
            max_tile_size: Taille max tile en pixels
            optimal_pixel_size: R√©solution optimale du mod√®le (None = auto)
        """
        tiles = []
        
        # Taille des pixels actuels
        layer_extent = raster_layer.extent()
        layer_width = raster_layer.width()
        layer_height = raster_layer.height()
        
        current_pixel_size_x = layer_extent.width() / layer_width
        current_pixel_size_y = layer_extent.height() / layer_height
        current_pixel_size = (current_pixel_size_x + current_pixel_size_y) / 2
        
        # NOUVEAUT√â: Adaptation taille tile selon r√©solution optimale
        adaptive_tile_size = max_tile_size
        if optimal_pixel_size and optimal_pixel_size > 0:
            scale_ratio = current_pixel_size / optimal_pixel_size
            
            # Si r√©solution actuelle plus fine ‚Üí tiles plus grandes
            # Si r√©solution actuelle plus grossi√®re ‚Üí tiles plus petites
            adaptive_tile_size = int(max_tile_size * scale_ratio)
            adaptive_tile_size = max(320, min(2048, adaptive_tile_size))  # Limites
            
            print(f"üîç √âCHELLE: R√©solution actuelle: {current_pixel_size:.3f}m/px")
            print(f"üîç √âCHELLE: R√©solution optimale: {optimal_pixel_size:.3f}m/px") 
            print(f"üîç √âCHELLE: Ratio: {scale_ratio:.2f}x")
            print(f"üîç √âCHELLE: Taille tile adapt√©e: {adaptive_tile_size}px (base: {max_tile_size}px)")
        
        pixel_size_x = current_pixel_size_x
        pixel_size_y = current_pixel_size_y
        
        # Taille de la zone en pixels
        zone_width_px = extent.width() / pixel_size_x
        zone_height_px = extent.height() / pixel_size_y
        
        # Si la zone est petite, traiter en une seule tile
        if zone_width_px <= adaptive_tile_size and zone_height_px <= adaptive_tile_size:
            tiles.append(extent)
            return tiles
        
        # Sinon, d√©couper en tiles adaptatives
        tile_width_map = pixel_size_x * adaptive_tile_size
        tile_height_map = pixel_size_y * adaptive_tile_size
        
        x_start = extent.xMinimum()
        y_start = extent.yMinimum()
        x_end = extent.xMaximum()
        y_end = extent.yMaximum()
        
        y = y_start
        while y < y_end:
            x = x_start
            while x < x_end:
                tile_x_max = min(x + tile_width_map, x_end)
                tile_y_max = min(y + tile_height_map, y_end)
                
                from qgis.core import QgsRectangle
                tile_extent = QgsRectangle(x, y, tile_x_max, tile_y_max)
                tiles.append(tile_extent)
                
                x = tile_x_max
            y = tile_y_max
        
        return tiles
    
    def _convert_detections_to_map_coords(self, detections: list, patch_data: dict, tile_extent) -> list:
        """Convertit les d√©tections YOLO en coordonn√©es carte"""
        map_detections = []
        
        extracted_bbox = patch_data['extracted_bbox']
        
        print(f"üîç DEBUG COORD: Conversion {len(detections)} d√©tections")
        print(f"üîç DEBUG COORD: Extracted bbox: {extracted_bbox}")
        print(f"üîç DEBUG COORD: Tile extent: {tile_extent}")
        
        for i, detection in enumerate(detections):
            # Coordonn√©es YOLO normalis√©es [center_x, center_y, width, height]
            yolo_bbox = detection['bbox_normalized']
            print(f"üîç DEBUG COORD: Detection {i+1} YOLO bbox: {yolo_bbox}")
            
            # Conversion vers coordonn√©es carte
            img_width = extracted_bbox['xmax'] - extracted_bbox['xmin']
            img_height = extracted_bbox['ymax'] - extracted_bbox['ymin']
            
            print(f"üîç DEBUG COORD: Image dimensions: {img_width} x {img_height}")
            
            # Centre de l'objet en coordonn√©es carte
            center_x_map = extracted_bbox['xmin'] + (yolo_bbox[0] * img_width)
            center_y_map = extracted_bbox['ymin'] + (yolo_bbox[1] * img_height)
            
            # Dimensions de l'objet en coordonn√©es carte  
            width_map = yolo_bbox[2] * img_width
            height_map = yolo_bbox[3] * img_height
            
            print(f"üîç DEBUG COORD: Centre carte: ({center_x_map}, {center_y_map})")
            print(f"üîç DEBUG COORD: Dimensions carte: {width_map} x {height_map}")
            
            # Bounding box finale
            bbox_map = {
                'xmin': center_x_map - width_map/2,
                'ymin': center_y_map - height_map/2,
                'xmax': center_x_map + width_map/2,
                'ymax': center_y_map + height_map/2
            }
            
            print(f"üîç DEBUG COORD: BBox finale: {bbox_map}")
            
            map_detection = {
                'bbox_map': bbox_map,
                'confidence': detection['confidence'],
                'class_id': detection['class_id'],
                'class_name': detection['class_name'],
                'center_x': center_x_map,
                'center_y': center_y_map
            }
            
            map_detections.append(map_detection)
        
        print(f"üîç DEBUG COORD: {len(map_detections)} d√©tections converties")
        return map_detections
    
    def _update_detection_progress_setup(self, total_tiles: int):
        """Configure la barre de progression pour la d√©tection"""
        self.detection_progress.setRange(0, total_tiles)
        self.detection_progress.setValue(0)
        self.status_label.setText(f"üîç D√©tection sur {total_tiles} zones...")
    
    def _update_detection_progress(self, processed: int, total: int):
        """Met √† jour la progression de la d√©tection"""
        self.detection_progress.setValue(processed)
        progress_percent = (processed / total) * 100 if total > 0 else 0
        self.status_label.setText(f"üîç D√©tection... {progress_percent:.1f}% ({processed}/{total} zones)")
    
    def _on_detection_completed(self, detections: list, zone_description: str, total_tiles: int):
        """Gestion de la fin de d√©tection"""
        try:
            num_detections = len(detections)
            
            print("=" * 80)
            print("üö®üö®üö® _ON_DETECTION_COMPLETED v1.3.4 - CLAUDE CODE üö®üö®üö®")
            print("=" * 80)
            print(f"üîç DEBUG FINAL: D√©tection termin√©e avec {num_detections} d√©tections")
            print(f"üîç DEBUG FINAL: Zone: {zone_description}, Tiles: {total_tiles}")
            
            # R√©initialisation de l'interface
            self._reset_detection_interface()
            
            # Cr√©ation de la couche de r√©sultats
            if num_detections > 0:
                print(f"üîç DEBUG FINAL: Cr√©ation de la couche de r√©sultats...")
                result_layer = self._create_detection_results_layer(detections)
                
                if result_layer:
                    from qgis.core import QgsProject
                    project = QgsProject.instance()
                    
                    print(f"üîç DEBUG FINAL: Ajout de la couche au projet...")
                    print(f"üîç DEBUG FINAL: Couche valide: {result_layer.isValid()}")
                    print(f"üîç DEBUG FINAL: Nombre de features: {result_layer.featureCount()}")
                    print(f"üîç DEBUG FINAL: Extent de la couche: {result_layer.extent()}")
                    
                    project.addMapLayer(result_layer)
                    
                    print(f"üîç DEBUG FINAL: Couche ajout√©e au projet")
                    print(f"üîç DEBUG FINAL: Couches dans le projet: {len(project.mapLayers())}")
                    
                    # Forcer le rafra√Æchissement du canvas
                    from qgis.utils import iface
                    if iface:
                        iface.mapCanvas().refresh()
                        print(f"üîç DEBUG FINAL: Canvas rafra√Æchi")
                    
                    # Zoom sur les r√©sultats
                    self.iface.mapCanvas().setExtent(result_layer.extent())
                    self.iface.mapCanvas().refresh()
            
            # Message de r√©sultats
            if num_detections > 0:
                message = (f"üéâ D√©tection termin√©e avec succ√®s !\n\n"
                          f"‚Ä¢ {num_detections} objets d√©tect√©s\n"
                          f"‚Ä¢ Zone : {zone_description}\n"  
                          f"‚Ä¢ {total_tiles} zones trait√©es\n\n"
                          f"Les r√©sultats ont √©t√© ajout√©s comme nouvelle couche vectorielle.")
                
                self.results_label.setText(f"‚úÖ {num_detections} objets d√©tect√©s")
                self.status_label.setText(f"‚úÖ D√©tection termin√©e - {num_detections} objets trouv√©s")
            else:
                message = (f"‚ÑπÔ∏è D√©tection termin√©e.\n\n"
                          f"‚Ä¢ Aucun objet d√©tect√©\n"
                          f"‚Ä¢ Zone : {zone_description}\n"
                          f"‚Ä¢ {total_tiles} zones trait√©es\n\n"
                          f"Essayez de r√©duire le seuil de confiance ou v√©rifiez que le mod√®le "
                          f"correspond au type d'objets pr√©sents dans l'image.")
                
                self.results_label.setText("‚ÑπÔ∏è Aucun objet d√©tect√©")
                self.status_label.setText("‚ÑπÔ∏è D√©tection termin√©e - Aucun objet trouv√©")
            
            QMessageBox.information(self, "D√©tection Termin√©e", message)
            
        except Exception as e:
            self._on_detection_error(f"Erreur post-d√©tection: {str(e)}")
    
    def _on_detection_error(self, error_message: str):
        """Gestion des erreurs de d√©tection"""
        self._reset_detection_interface()
        
        QMessageBox.critical(
            self,
            "Erreur de D√©tection", 
            f"La d√©tection d'objets a √©chou√© :\n\n{error_message}"
        )
        
        self.results_label.setText("‚ùå Erreur lors de la d√©tection")
        self.status_label.setText("‚ùå Erreur d√©tection - V√©rifiez les param√®tres")
    
    def _reset_detection_interface(self):
        """Remet l'interface de d√©tection √† l'√©tat initial"""
        self.detect_btn.setText("üîç D√©tecter les Objets")
        self.detect_btn.setEnabled(True)
        self.detection_progress.setVisible(False)
    
    def _create_detection_results_layer(self, detections: list):
        """Cr√©e une couche vectorielle avec les r√©sultats de d√©tection (bbox polygonales)"""
        try:
            from qgis.core import (QgsVectorLayer, QgsField, QgsFeature, QgsGeometry, 
                                   QgsPointXY, QgsRectangle, QgsSymbol, QgsSingleSymbolRenderer,
                                   QgsFillSymbol)
            from qgis.PyQt.QtCore import QVariant
            from qgis.PyQt.QtGui import QColor
            from datetime import datetime
            
            print("=" * 80)
            print("üö®üö®üö® VERSION DEBUG v1.3.4 ACTIV√âE - CLAUDE CODE üö®üö®üö®")
            print("=" * 80)
            print(f"üîç DEBUG: Cr√©ation couche pour {len(detections)} d√©tections")
            
            # Cr√©ation de la couche vectorielle (POLYGONES) avec le CRS du projet
            from qgis.core import QgsProject
            project_crs = QgsProject.instance().crs()
            print(f"üîç DEBUG: CRS du projet: {project_crs.authid()}")
            
            layer = QgsVectorLayer(f"Polygon?crs={project_crs.authid()}", "YOLO_Detections", "memory")
            
            if not layer.isValid():
                print("‚ùå DEBUG: Erreur cr√©ation couche de r√©sultats")
                return None
            
            print(f"‚úÖ DEBUG: Couche cr√©√©e avec succ√®s")
            
            # Ajout des champs avec m√©tadonn√©es compl√®tes
            provider = layer.dataProvider()
            provider.addAttributes([
                QgsField("class_name", QVariant.String),
                QgsField("confidence", QVariant.Double),
                QgsField("confidence_pct", QVariant.String),  # Pourcentage format√©
                QgsField("center_x", QVariant.Double),
                QgsField("center_y", QVariant.Double),
                QgsField("bbox_xmin", QVariant.Double),
                QgsField("bbox_ymin", QVariant.Double), 
                QgsField("bbox_xmax", QVariant.Double),
                QgsField("bbox_ymax", QVariant.Double),
                QgsField("bbox_width", QVariant.Double),
                QgsField("bbox_height", QVariant.Double),
                QgsField("detection_time", QVariant.String),
                QgsField("model_used", QVariant.String)
            ])
            layer.updateFields()
            
            print(f"üîç DEBUG: Champs ajout√©s: {[field.name() for field in layer.fields()]}")
            
            # R√©cup√©ration du mod√®le utilis√© pour les m√©tadonn√©es
            current_model_name = "Unknown"
            if hasattr(self, 'detection_class_combo') and self.detection_class_combo.currentData():
                model = self.get_model_for_class(self.detection_class_combo.currentData())
                if model:
                    current_model_name = model.get('name', 'Unknown')
            
            # Validation des d√©tections
            if not detections:
                print("‚ùå DEBUG: Aucune d√©tection √† traiter")
                return None
                
            print(f"üîç DEBUG: Exemple de d√©tection: {detections[0]}")
            
            # Ajout des features avec g√©om√©tries bbox
            features = []
            detection_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            print(f"üîç DEBUG: D√©but cr√©ation de {len(detections)} features")
            
            for i, detection in enumerate(detections):
                # Validation de la d√©tection
                if 'bbox_map' not in detection:
                    print(f"‚ùå DEBUG: Feature {i+1} sans bbox_map")
                    continue
                    
                feature = QgsFeature(layer.fields())
                
                # G√©om√©trie : rectangle (bbox) au lieu de point
                bbox = detection['bbox_map']
                print(f"üîç DEBUG: Bbox: {bbox}")
                
                # V√©rification de la validit√© des coordonn√©es
                if (bbox['xmin'] >= bbox['xmax'] or bbox['ymin'] >= bbox['ymax']):
                    print(f"‚ùå DEBUG: Bbox invalide pour feature {i+1}: xmin={bbox['xmin']}, xmax={bbox['xmax']}, ymin={bbox['ymin']}, ymax={bbox['ymax']}")
                    continue
                
                # Conversion des types NumPy vers types Python natifs
                bbox_native = {}
                for key, value in bbox.items():
                    # Conversion explicite des types NumPy vers float Python
                    if hasattr(value, 'item'):  # NumPy types have .item() method
                        bbox_native[key] = float(value.item())
                    else:
                        bbox_native[key] = float(value)
                    
                    # V√©rification des valeurs NaN ou infinies
                    if str(bbox_native[key]).lower() in ['nan', 'inf', '-inf']:
                        print(f"‚ùå DEBUG: Valeur invalide dans bbox: {key}={bbox_native[key]}")
                        continue
                
                bbox = bbox_native  # Utiliser les valeurs converties
                print(f"üîç DEBUG: Bbox convertie: {bbox}")
                
                # NOUVEAU: Utilisation des polygones SAM si disponibles
                if detection.get('polygon_points') and detection.get('polygon_available'):
                    print(f"üî∫ DEBUG: Utilisation polygone SAM avec {len(detection['polygon_points'])} vertices")
                    
                    # Cr√©er un polygone pr√©cis √† partir des points SAM
                    polygon_points = detection['polygon_points']
                    qgs_points = []
                    
                    for point in polygon_points:
                        # Les points sont en coordonn√©es map (d√©j√† transform√©s)
                        qgs_points.append(QgsPointXY(float(point[0]), float(point[1])))
                    
                    # Fermer le polygone si n√©cessaire
                    if qgs_points and (qgs_points[0].x() != qgs_points[-1].x() or qgs_points[0].y() != qgs_points[-1].y()):
                        qgs_points.append(qgs_points[0])
                    
                    geometry = QgsGeometry.fromPolygonXY([qgs_points])
                    print(f"‚úÖ DEBUG: G√©om√©trie polygone SAM cr√©√©e avec {len(qgs_points)} points")
                    
                else:
                    print(f"üì¶ DEBUG: Utilisation bbox rectangulaire (pas de polygone SAM)")
                    
                    # Fallback bbox rectangulaire
                    rectangle = QgsRectangle(
                        bbox['xmin'], bbox['ymin'],
                        bbox['xmax'], bbox['ymax']
                    )
                    
                    print(f"üîç DEBUG: QgsRectangle cr√©√©: {rectangle.toString()}")
                    print(f"üîç DEBUG: Rectangle vide: {rectangle.isEmpty()}")
                    print(f"üîç DEBUG: Rectangle valide: {not rectangle.isNull()}")
                    
                    geometry = QgsGeometry.fromRect(rectangle)
                
                print(f"üîç DEBUG: G√©om√©trie valide: {not geometry.isNull()}")
                print(f"üîç DEBUG: Type g√©om√©trie: {geometry.type()}")
                print(f"üîç DEBUG: G√©om√©trie vide: {geometry.isEmpty()}")
                
                if geometry.isNull() or geometry.isEmpty():
                    print(f"‚ùå DEBUG: G√©om√©trie nulle ou vide pour feature {i+1}")
                    continue
                    
                feature.setGeometry(geometry)
                print(f"‚úÖ DEBUG: G√©om√©trie d√©finie pour feature {i+1}")
                
                # Calcul des dimensions
                width = bbox['xmax'] - bbox['xmin']
                height = bbox['ymax'] - bbox['ymin']
                
                # Conversion de toutes les valeurs NumPy vers types Python natifs
                confidence = float(detection['confidence'].item()) if hasattr(detection['confidence'], 'item') else float(detection['confidence'])
                center_x = float(detection['center_x'].item()) if hasattr(detection['center_x'], 'item') else float(detection['center_x'])
                center_y = float(detection['center_y'].item()) if hasattr(detection['center_y'], 'item') else float(detection['center_y'])
                
                # Attributs complets avec m√©tadonn√©es - TOUS TYPES PYTHON NATIFS
                attributes = [
                    str(detection['class_name']),                   # Classe d√©tect√©e (string)
                    round(confidence, 4),                           # Confiance (float)
                    f"{confidence*100:.1f}%",                      # Pourcentage format√© (string)
                    round(center_x, 2),                            # Centre X (float)
                    round(center_y, 2),                            # Centre Y (float)
                    round(bbox['xmin'], 2),                        # Bbox limites (float)
                    round(bbox['ymin'], 2),                        # (float)
                    round(bbox['xmax'], 2),                        # (float)
                    round(bbox['ymax'], 2),                        # (float)
                    round(width, 2),                               # Dimensions (float)
                    round(height, 2),                              # (float)
                    str(detection_time),                           # Timestamp (string)
                    str(current_model_name)                        # Mod√®le utilis√© (string)
                ]
                
                print(f"üîç DEBUG: Attributs types: {[type(attr).__name__ for attr in attributes]}")
                
                feature.setAttributes(attributes)
                print(f"‚úÖ DEBUG: Attributs d√©finis pour feature {i+1}: {attributes[:3]}...")
                
                features.append(feature)
            
            print(f"üîç DEBUG: {len(features)} features cr√©√©es")
            
            # Ajout des features au provider
            if features:
                print(f"üîç DEBUG: Tentative d'ajout de {len(features)} features")
                
                # V√©rification d√©taill√©e avant ajout
                valid_features = []
                for i, feature in enumerate(features):
                    print(f"üîç DEBUG: Feature {i+1} - Valide: {feature.isValid()}")
                    print(f"üîç DEBUG: Feature {i+1} - A g√©om√©trie: {feature.hasGeometry()}")
                    if feature.hasGeometry():
                        geom = feature.geometry()
                        print(f"üîç DEBUG: Feature {i+1} - G√©om√©trie valide: {not geom.isNull()}")
                        print(f"üîç DEBUG: Feature {i+1} - G√©om√©trie vide: {geom.isEmpty()}")
                        print(f"üîç DEBUG: Feature {i+1} - Aire: {geom.area()}")
                        if not geom.isNull() and not geom.isEmpty():
                            valid_features.append(feature)
                        else:
                            print(f"‚ùå DEBUG: Feature {i+1} rejet√©e - g√©om√©trie invalide")
                    else:
                        print(f"‚ùå DEBUG: Feature {i+1} rejet√©e - pas de g√©om√©trie")
                
                print(f"üîç DEBUG: {len(valid_features)} features valides sur {len(features)}")
                
                if valid_features:
                    result = provider.addFeatures(valid_features)
                    print(f"üîç DEBUG: Ajout features au provider: {result}")
                    print(f"üîç DEBUG: Nombre features dans la couche apr√®s ajout: {layer.featureCount()}")
                    
                    # V√©rification finale des features dans la couche
                    feature_iter = layer.getFeatures()
                    count = 0
                    for feature in feature_iter:
                        count += 1
                        print(f"üîç DEBUG: Feature {count} dans couche - ID: {feature.id()}, Attributs: {len(feature.attributes())}")
                    print(f"üîç DEBUG: Total it√©r√©: {count} features")
                else:
                    print("‚ùå DEBUG: Aucune feature valide √† ajouter")
            else:
                print("‚ùå DEBUG: Aucune feature √† ajouter")
                
            layer.updateExtents()
            print(f"üîç DEBUG: Extent de la couche: {layer.extent()}")
            
            # Style visuel optimis√© pour les bbox
            fill_symbol = QgsFillSymbol.createSimple({
                'color': '255,0,0,60',           # Rouge semi-transparent
                'outline_color': '255,0,0,255',  # Contour rouge opaque
                'outline_width': '2',            # Contour √©pais
                'outline_style': 'solid'         # Ligne continue
            })
            
            renderer = QgsSingleSymbolRenderer(fill_symbol)
            layer.setRenderer(renderer)
            
            # Nom descriptif avec timestamp et nombre de d√©tections
            timestamp = datetime.now().strftime("%H:%M:%S")
            layer.setName(f"YOLO_Detections_{len(detections)}obj_{timestamp}")
            
            print(f"‚úÖ Couche cr√©√©e: {len(detections)} d√©tections avec bbox polygonales")
            
            return layer
            
        except Exception as e:
            print(f"Erreur cr√©ation couche r√©sultats: {e}")
            return None
    
    def refresh_interface_display(self):
        """Force la mise √† jour compl√®te de l'affichage de l'interface"""
        try:
            print("üîÑ Rafra√Æchissement complet de l'interface...")
            
            # Mise √† jour des arbres et combos
            if self.annotation_manager:
                self.update_classes_tree_with_real_stats() 
            else:
                self.update_classes_tree()
            
            self.update_class_combos()
            self.update_interface_state()
            
            # Informations de debug
            print(f"üìä Classes en m√©moire: {list(self.object_classes.keys())}")
            print(f"üìã Items dans l'arbre: {self.classes_tree.topLevelItemCount()}")
            print(f"üéØ Classes dans combo annotation: {[self.active_class_combo.itemText(i) for i in range(self.active_class_combo.count())]}")
            
            print("‚úÖ Rafra√Æchissement termin√©")
            
        except Exception as e:
            print(f"‚ùå Erreur rafra√Æchissement interface: {e}")
            import traceback
            traceback.print_exc()
    
    def on_active_class_changed(self, class_name):
        """Gestion du changement de classe active dans le combo"""
        print(f"üîÑ Signal changement classe: '{class_name}'")
        
        if class_name and not class_name.startswith("---"):
            # V√©rifier que la classe existe bien
            if class_name in self.object_classes:
                self.current_class = class_name
                print(f"üéØ Classe active chang√©e: {class_name}")
                
                # Mise √† jour de l'interface
                self.update_annotation_progress()
                self.update_examples_list()
                self.update_interface_state()
                
                # Synchronisation avec l'arbre
                items = self.classes_tree.findItems(class_name, Qt.MatchExactly, 0)
                if items:
                    # Bloquer temporairement les signaux pour √©viter la r√©cursion
                    self.classes_tree.blockSignals(True)
                    self.classes_tree.setCurrentItem(items[0])
                    self.classes_tree.blockSignals(False)
                
                # Message de confirmation
                self.status_label.setText(f"üéØ Classe '{class_name}' s√©lectionn√©e pour annotation")
            else:
                print(f"‚ö†Ô∏è Classe '{class_name}' non trouv√©e dans object_classes")
                self.current_class = None
        else:
            self.current_class = None
            print("‚ö™ Aucune classe active s√©lectionn√©e")
            self.status_label.setText("‚ö™ S√©lectionnez une classe pour commencer l'annotation")
        
        # CORRECTION: Mise √† jour imm√©diate de l'√©tat des boutons
        self.update_interface_state()
        print(f"‚öôÔ∏è Bouton annotation activ√©: {self.start_annotation_btn.isEnabled()}")
    
    def edit_selected_class(self):
        """Modifie la classe s√©lectionn√©e"""
        current_item = self.classes_tree.currentItem()
        if not current_item:
            QMessageBox.warning(self, "Attention", "Veuillez s√©lectionner une classe √† modifier.")
            return
        
        class_name = current_item.text(0)
        if class_name not in self.object_classes:
            QMessageBox.warning(self, "Erreur", f"Classe '{class_name}' non trouv√©e.")
            return
        
        # Dialog de modification
        from qgis.PyQt.QtWidgets import QInputDialog
        new_description, ok = QInputDialog.getText(
            self, "Modifier Classe", 
            f"Description pour '{class_name}':",
            text=self.object_classes[class_name].get('description', '')
        )
        
        if ok:
            self.object_classes[class_name]['description'] = new_description
            if self.annotation_manager:
                self.annotation_manager.create_class(class_name, new_description)
            
            self.update_classes_tree_with_real_stats()
            self.status_label.setText(f"‚úÖ Classe '{class_name}' modifi√©e")
    
    def duplicate_selected_class(self):
        """Duplique la classe s√©lectionn√©e"""
        current_item = self.classes_tree.currentItem()
        if not current_item:
            QMessageBox.warning(self, "Attention", "Veuillez s√©lectionner une classe √† dupliquer.")
            return
        
        class_name = current_item.text(0)
        if class_name not in self.object_classes:
            QMessageBox.warning(self, "Erreur", f"Classe '{class_name}' non trouv√©e.")
            return
        
        # Dialog pour nouveau nom
        from qgis.PyQt.QtWidgets import QInputDialog
        new_name, ok = QInputDialog.getText(
            self, "Dupliquer Classe", 
            f"Nouveau nom pour la copie de '{class_name}':",
            text=f"{class_name}_copie"
        )
        
        if ok and new_name:
            if new_name in self.object_classes:
                QMessageBox.warning(self, "Erreur", f"La classe '{new_name}' existe d√©j√†.")
                return
            
            # Duplication des donn√©es
            original_data = self.object_classes[class_name].copy()
            original_data['name'] = new_name
            original_data['description'] = f"Copie de {class_name}: " + original_data.get('description', '')
            original_data['examples'] = []  # Nouvelle classe sans exemples
            original_data['created_at'] = datetime.now()
            
            self.object_classes[new_name] = original_data
            
            if self.annotation_manager:
                self.annotation_manager.create_class(new_name, original_data['description'], original_data['color'])
            
            self.update_classes_tree_with_real_stats()
            self.update_class_combos()
            self.status_label.setText(f"‚úÖ Classe '{new_name}' cr√©√©e par duplication")
    
    def delete_selected_class(self):
        """Supprime la classe s√©lectionn√©e"""
        current_item = self.classes_tree.currentItem()
        if not current_item:
            QMessageBox.warning(self, "Attention", "Veuillez s√©lectionner une classe √† supprimer.")
            return
        
        class_name = current_item.text(0)
        if class_name not in self.object_classes:
            QMessageBox.warning(self, "Erreur", f"Classe '{class_name}' non trouv√©e.")
            return
        
        # Confirmation avec nombre d'exemples
        example_count = 0
        if self.annotation_manager:
            try:
                stats = self.annotation_manager.get_class_statistics(class_name)
                example_count = stats.example_count
            except:
                pass
        
        reply = QMessageBox.question(
            self, "Confirmer Suppression",
            f"Supprimer la classe '{class_name}' ?\n\n"
            f"Cette action supprimera aussi:\n"
            f"- {example_count} exemples d'annotation\n"
            f"- Toutes les donn√©es associ√©es\n\n"
            f"Cette action est irr√©versible.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Suppression de l'interface
            del self.object_classes[class_name]
            
            # TODO: Suppression de la base de donn√©es (n√©cessite impl√©mentation dans AnnotationManager)
            # if self.annotation_manager:
            #     self.annotation_manager.delete_class(class_name)
            
            # Mise √† jour interface
            self.update_classes_tree_with_real_stats()
            self.update_class_combos()
            
            # R√©initialiser la classe active si n√©cessaire
            if self.current_class == class_name:
                self.current_class = None
                self.update_interface_state()
            
            self.status_label.setText(f"‚úÖ Classe '{class_name}' supprim√©e")
    
    def export_selected_class(self):
        """Exporte la classe s√©lectionn√©e"""
        current_item = self.classes_tree.currentItem()
        if not current_item:
            QMessageBox.warning(self, "Attention", "Veuillez s√©lectionner une classe √† exporter.")
            return
        
        class_name = current_item.text(0)
        if class_name not in self.object_classes:
            QMessageBox.warning(self, "Erreur", f"Classe '{class_name}' non trouv√©e.")
            return
        
        # Dialog de s√©lection du fichier
        file_path, _ = QFileDialog.getSaveFileName(
            self, f"Exporter Classe '{class_name}'",
            f"{class_name}_export.json",
            "Fichiers JSON (*.json);;Tous les fichiers (*)"
        )
        
        if file_path:
            try:
                # Pr√©paration des donn√©es d'export
                export_data = {
                    'class_info': self.object_classes[class_name],
                    'export_date': datetime.now().isoformat(),
                    'plugin_version': '1.1.11'
                }
                
                # Ajout des statistiques si disponibles
                if self.annotation_manager:
                    try:
                        stats = self.annotation_manager.get_class_statistics(class_name)
                        annotations = self.annotation_manager.get_class_annotations(class_name)
                        export_data['statistics'] = {
                            'example_count': stats.example_count,
                            'quality_score': stats.quality_score,
                            'ready_for_training': stats.ready_for_training
                        }
                        export_data['annotations_count'] = len(annotations)
                    except Exception as e:
                        export_data['export_note'] = f"Erreur r√©cup√©ration statistiques: {str(e)}"
                
                # Sauvegarde
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(export_data, f, indent=2, ensure_ascii=False, default=str)
                
                QMessageBox.information(self, "Export R√©ussi", 
                    f"Classe '{class_name}' export√©e vers:\n{file_path}")
                self.status_label.setText(f"‚úÖ Classe '{class_name}' export√©e")
                
            except Exception as e:
                QMessageBox.critical(self, "Erreur Export", 
                    f"Impossible d'exporter la classe '{class_name}':\n{str(e)}")
                self.status_label.setText(f"‚ùå Erreur export '{class_name}'")

    # ============================================================================
    # NOUVEAU: M√©thodes de gestion Smart Mode
    # ============================================================================
    
    def on_intelligence_mode_changed(self, checked):
        """Gestion du changement de mode d'intelligence (Manuel/Smart)"""
        sender = self.sender()
        
        if sender == self.manual_mode_btn and checked:
            # Mode manuel activ√©
            self.smart_mode_btn.setChecked(False)
            self.smart_mode_enabled = False
            self.smart_config_group.setVisible(False)
            self.smart_status_label.setText("‚úã Mode manuel actif")
            self.auto_detect_btn.setEnabled(False)  # D√©sactiver d√©tection auto
            print("üñ±Ô∏è Mode annotation manuel activ√©")
            
        elif sender == self.smart_mode_btn and checked:
            # Mode smart activ√©
            self.manual_mode_btn.setChecked(False)
            self.smart_mode_enabled = True
            self.smart_config_group.setVisible(True)
            self._initialize_smart_engine()
            self.auto_detect_btn.setEnabled(True)  # Activer d√©tection auto
            print("ü§ñ Mode smart assistant activ√©")
            print(f"üîç DEBUG SMART MODE: smart_mode_enabled={self.smart_mode_enabled}")
            print(f"üîç DEBUG SMART MODE: precise_contours_checkbox={self.precise_contours_checkbox.isChecked()}")
        
        # Mise √† jour de l'outil d'annotation si actif
        if self.annotation_tool and hasattr(self.annotation_tool, 'set_smart_mode'):
            print(f"üîç DEBUG TRANSMISSION: Envoi smart_mode_enabled={self.smart_mode_enabled} vers annotation_tool")
            self.annotation_tool.set_smart_mode(self.smart_mode_enabled)
            print(f"üîç DEBUG TRANSMISSION: annotation_tool.smart_mode_enabled={getattr(self.annotation_tool, 'smart_mode_enabled', 'MISSING')}")
    
    def _initialize_smart_engine(self):
        """Initialise le SmartAnnotationEngine de mani√®re asynchrone"""
        if self.smart_engine is not None:
            # D√©j√† initialis√©
            self.smart_status_label.setText("‚úÖ Smart Engine pr√™t")
            return
        
        self.smart_status_label.setText("‚è≥ Initialisation Smart Engine...")
        
        # Utilisation d'un QTimer pour initialisation non-bloquante
        from qgis.PyQt.QtCore import QTimer
        
        def init_async():
            try:
                # V√©rification des pr√©requis avant initialisation
                if not self.yolo_engine:
                    self.smart_status_label.setText("‚ùå YOLOEngine non disponible")
                    return
                
                if not self.annotation_manager:
                    self.smart_status_label.setText("‚ùå AnnotationManager non disponible")
                    return
                
                # Import et initialisation s√©curis√©s
                from ..core.smart_annotation_engine import SmartAnnotationEngine
                self.smart_engine = SmartAnnotationEngine(
                    yolo_engine=self.yolo_engine,
                    annotation_manager=self.annotation_manager
                )
                
                # Configuration selon les param√®tres UI
                self.smart_engine.enable_debug_mode(self.debug_mode_checkbox.isChecked())
                
                # Mise √† jour du statut
                cpu_profile = self.smart_engine.cpu_profile.level
                self.smart_status_label.setText(f"‚úÖ Smart Engine pr√™t (CPU: {cpu_profile})")
                
                print(f"ü§ñ SmartAnnotationEngine initialis√© avec profil CPU: {cpu_profile}")
                
            except Exception as e:
                print(f"‚ùå Erreur initialisation SmartAnnotationEngine: {e}")
                self.smart_status_label.setText("‚ùå Erreur initialisation")
                
                # Fallback vers mode manuel
                self.manual_mode_btn.setChecked(True)
                self.smart_mode_btn.setChecked(False)
                self.smart_mode_enabled = False
                self.smart_config_group.setVisible(False)
        
        QTimer.singleShot(100, init_async)
    
    def update_yolo_confidence_label(self, value):
        """Met √† jour le label de confiance YOLO"""
        self.yolo_confidence_label.setText(f"{value}%")
    
    def on_smart_config_changed(self):
        """Gestion des changements de configuration Smart Mode"""
        if self.smart_engine is None:
            return
        
        try:
            # Mise √† jour de la configuration du Smart Engine
            if hasattr(self.smart_engine, 'cpu_profile'):
                # Mise √† jour du seuil de confiance YOLO
                confidence_pct = self.yolo_confidence_slider.value()
                self.smart_engine.cpu_profile.confidence_threshold_yolo = confidence_pct / 100.0
                
                # Activation/d√©sactivation SAM
                self.smart_engine.cpu_profile.enable_sam = self.enable_sam_checkbox.isChecked()
                
                # Contours pr√©cis (polygones SAM)
                if hasattr(self.smart_engine, 'enable_precise_contours'):
                    checkbox_value = self.precise_contours_checkbox.isChecked()
                    self.smart_engine.enable_precise_contours = checkbox_value
                    print(f"üîç DEBUG CONTOURS: precise_contours_checkbox={checkbox_value}")
                    print(f"üîç DEBUG CONTOURS: smart_engine.enable_precise_contours={self.smart_engine.enable_precise_contours}")
                else:
                    print("‚ö†Ô∏è DEBUG CONTOURS: smart_engine n'a pas d'attribut 'enable_precise_contours'")
                
                # Mode debug
                self.smart_engine.enable_debug_mode(self.debug_mode_checkbox.isChecked())
                
                contours_status = "Polygones" if self.precise_contours_checkbox.isChecked() else "BBox"
                print(f"üîß Smart Engine configur√©: YOLO={confidence_pct}%, SAM={self.enable_sam_checkbox.isChecked()}, Contours={contours_status}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur configuration Smart Engine: {e}")
    
    def get_smart_detection_result(self, user_rect, raster_patch, target_class):
        """
        Interface pour obtenir un r√©sultat de d√©tection intelligente
        
        Args:
            user_rect: Rectangle utilisateur (x1, y1, x2, y2)
            raster_patch: Patch raster extrait
            target_class: Classe cible
            
        Returns:
            SmartDetectionResult ou None si mode manuel
        """
        if not self.smart_mode_enabled or self.smart_engine is None:
            return None
        
        try:
            result = self.smart_engine.smart_detect_from_user_rectangle(
                user_rect, raster_patch, target_class
            )
            
            # Mise √† jour des statistiques dans l'interface
            if hasattr(result, 'processing_time'):
                stats = self.smart_engine.get_performance_stats()
                stats_text = (f"üìä Smart Stats: {stats['total_detections']} d√©tections, "
                             f"SAM: {stats['sam_usage_rate']:.1f}%, "
                             f"Auto: {stats['auto_acceptance_rate']:.1f}%, "
                             f"Temps moy: {stats['avg_processing_time_ms']:.1f}ms")
                
                # Affichage temporaire dans le status
                self.status_label.setText(stats_text)
                
                # Retour au status normal apr√®s 3s
                from qgis.PyQt.QtCore import QTimer
                QTimer.singleShot(3000, lambda: self.status_label.setText("‚úÖ Annotation intelligente termin√©e"))
            
            return result
            
        except Exception as e:
            print(f"‚ùå Erreur d√©tection intelligente: {e}")
            return None
    
    def cleanup_smart_engine(self):
        """Nettoie le Smart Engine"""
        if self.smart_engine is not None:
            try:
                self.smart_engine.cleanup()
                print("‚úÖ Smart Engine nettoy√©")
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur nettoyage Smart Engine: {e}")
            finally:
                self.smart_engine = None
    
    def start_smart_auto_detection(self):
        """
        NOUVEAU: Lance la d√©tection automatique Smart Mode
        
        YOLO scanne la zone visible et propose automatiquement des bbox
        """
        if not self.smart_mode_enabled or not self.smart_engine:
            QMessageBox.warning(
                self, 
                "Smart Mode Requis", 
                "La d√©tection automatique n√©cessite le Smart Mode activ√©.\n\n"
                "Activez d'abord 'ü§ñ Smart Assistant' ci-dessus."
            )
            return
        
        # V√©rification classe active
        if not self.current_class:
            QMessageBox.warning(
                self,
                "Classe Manquante",
                "S√©lectionnez d'abord une classe √† d√©tecter dans le dropdown 'Classe √† annoter'"
            )
            return
        
        # D√©l√©guer √† l'annotation tool
        if self.annotation_tool and hasattr(self.annotation_tool, 'start_smart_auto_detection'):
            try:
                # S'assurer que l'outil a la bonne classe active
                self.annotation_tool.set_active_class(self.current_class)
                
                # Lancer la d√©tection automatique
                self.annotation_tool.start_smart_auto_detection()
                
            except Exception as e:
                print(f"‚ùå Erreur d√©tection automatique: {e}")
                QMessageBox.critical(
                    self,
                    "Erreur D√©tection",
                    f"Erreur lors de la d√©tection automatique:\n\n{str(e)}"
                )
        else:
            QMessageBox.warning(
                self,
                "Fonctionnalit√© Indisponible",
                "L'outil d'annotation n'est pas correctement initialis√©.\n\n"
                "Essayez de red√©marrer le plugin."
            )

    def accept(self):
        """M√©thode de compatibilit√© avec QDialog - masque le dock widget"""
        self.setVisible(False)
        
    def reject(self):
        """M√©thode de compatibilit√© avec QDialog - masque le dock widget"""
        self.setVisible(False)
        
    def closeEvent(self, event):
        """Gestion de la fermeture de la fen√™tre"""
        # Nettoyage si n√©cessaire
        if self.start_annotation_btn.isChecked():
            self.start_annotation_btn.setChecked(False)
        
        # D√©sactivation de l'outil d'annotation
        if self.annotation_tool and self.iface.mapCanvas().mapTool() == self.annotation_tool:
            self.iface.mapCanvas().unsetMapTool(self.annotation_tool)
        
        # NOUVEAU: Nettoyage Smart Engine
        self.cleanup_smart_engine()
        
        # Nettoyage YOLOEngine si en cours d'entra√Ænement
        if self.training_in_progress and self.yolo_engine:
            self.yolo_engine.cleanup()
        
        event.accept()
    
    def show_class_detail(self):
        """Affiche les d√©tails d'une classe dans un dialog simple"""
        # R√©cup√©rer la classe s√©lectionn√©e
        current_item = self.classes_tree.currentItem()
        if not current_item:
            QMessageBox.information(self, "Information", "Veuillez s√©lectionner une classe")
            return
        
        class_name = current_item.text(0)
        
        try:
            # R√©cup√©rer les exemples de cette classe
            examples = self.annotation_manager.get_class_examples(class_name)
            
            # Cr√©er le dialog de d√©tails
            from .class_detail_dialog import ClassDetailDialog
            dialog = ClassDetailDialog(class_name, examples, self)
            dialog.exec_()
            
        except Exception as e:
            # Fallback simple si le dialog d√©taill√© n'est pas disponible
            example_count = len(examples) if 'examples' in locals() else 0
            
            QMessageBox.information(
                self, 
                f"D√©tails - {class_name}",
                f"Classe: {class_name}\n"
                f"Exemples: {example_count}\n"
                f"Status: Pr√™t pour entra√Ænement" if example_count >= 10 else f"Status: {10-example_count} exemples manquants"
            )
    
